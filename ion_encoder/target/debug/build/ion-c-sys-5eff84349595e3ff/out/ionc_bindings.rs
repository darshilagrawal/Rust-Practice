/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const DECQUADNAME: &'static [u8; 12usize] = b"decimalQuad\0";
pub const DECQUADTITLE: &'static [u8; 22usize] = b"Decimal 128-bit datum\0";
pub const DECQUADAUTHOR: &'static [u8; 15usize] = b"Mike Cowlishaw\0";
pub const DECQUAD_Bytes: u32 = 16;
pub const DECQUAD_Pmax: u32 = 34;
pub const DECQUAD_Emin: i32 = -6143;
pub const DECQUAD_Emax: u32 = 6144;
pub const DECQUAD_EmaxD: u32 = 4;
pub const DECQUAD_Bias: u32 = 6176;
pub const DECQUAD_String: u32 = 43;
pub const DECQUAD_EconL: u32 = 12;
pub const DECQUAD_Declets: u32 = 11;
pub const DECQUAD_Ehigh: u32 = 12287;
pub const DECCNAME: &'static [u8; 11usize] = b"decContext\0";
pub const DECCFULLNAME: &'static [u8; 27usize] = b"Decimal Context Descriptor\0";
pub const DECCAUTHOR: &'static [u8; 15usize] = b"Mike Cowlishaw\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 110300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const _X86_INSTRUCTION_STATE_MAX_INSN_BYTES: u32 = 2380;
pub const _X86_INSTRUCTION_STATE_CACHELINE_SIZE: u32 = 64;
pub const __LASTBRANCH_MAX: u32 = 32;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const DECEXTFLAG: u32 = 1;
pub const DECSUBSET: u32 = 0;
pub const DEC_MAX_DIGITS: u32 = 999999999;
pub const DEC_MIN_DIGITS: u32 = 1;
pub const DEC_MAX_EMAX: u32 = 999999999;
pub const DEC_MIN_EMAX: u32 = 0;
pub const DEC_MAX_EMIN: u32 = 0;
pub const DEC_MIN_EMIN: i32 = -999999999;
pub const DEC_MAX_MATH: u32 = 999999;
pub const DEC_ClassString_SN: &'static [u8; 5usize] = b"sNaN\0";
pub const DEC_ClassString_QN: &'static [u8; 4usize] = b"NaN\0";
pub const DEC_ClassString_NI: &'static [u8; 10usize] = b"-Infinity\0";
pub const DEC_ClassString_NN: &'static [u8; 8usize] = b"-Normal\0";
pub const DEC_ClassString_NS: &'static [u8; 11usize] = b"-Subnormal\0";
pub const DEC_ClassString_NZ: &'static [u8; 6usize] = b"-Zero\0";
pub const DEC_ClassString_PZ: &'static [u8; 6usize] = b"+Zero\0";
pub const DEC_ClassString_PS: &'static [u8; 11usize] = b"+Subnormal\0";
pub const DEC_ClassString_PN: &'static [u8; 8usize] = b"+Normal\0";
pub const DEC_ClassString_PI: &'static [u8; 10usize] = b"+Infinity\0";
pub const DEC_ClassString_UN: &'static [u8; 8usize] = b"Invalid\0";
pub const DEC_Conversion_syntax: u32 = 1;
pub const DEC_Division_by_zero: u32 = 2;
pub const DEC_Division_impossible: u32 = 4;
pub const DEC_Division_undefined: u32 = 8;
pub const DEC_Insufficient_storage: u32 = 16;
pub const DEC_Inexact: u32 = 32;
pub const DEC_Invalid_context: u32 = 64;
pub const DEC_Invalid_operation: u32 = 128;
pub const DEC_Overflow: u32 = 512;
pub const DEC_Clamped: u32 = 1024;
pub const DEC_Rounded: u32 = 2048;
pub const DEC_Subnormal: u32 = 4096;
pub const DEC_Underflow: u32 = 8192;
pub const DEC_IEEE_754_Division_by_zero: u32 = 2;
pub const DEC_IEEE_754_Inexact: u32 = 32;
pub const DEC_IEEE_754_Invalid_operation: u32 = 221;
pub const DEC_IEEE_754_Overflow: u32 = 512;
pub const DEC_IEEE_754_Underflow: u32 = 8192;
pub const DEC_Errors: u32 = 8927;
pub const DEC_NaNs: u32 = 221;
pub const DEC_Information: u32 = 3104;
pub const DEC_IEEE_854_Division_by_zero: u32 = 2;
pub const DEC_IEEE_854_Inexact: u32 = 32;
pub const DEC_IEEE_854_Invalid_operation: u32 = 221;
pub const DEC_IEEE_854_Overflow: u32 = 512;
pub const DEC_IEEE_854_Underflow: u32 = 8192;
pub const DEC_Condition_CS: &'static [u8; 18usize] = b"Conversion syntax\0";
pub const DEC_Condition_DZ: &'static [u8; 17usize] = b"Division by zero\0";
pub const DEC_Condition_DI: &'static [u8; 20usize] = b"Division impossible\0";
pub const DEC_Condition_DU: &'static [u8; 19usize] = b"Division undefined\0";
pub const DEC_Condition_IE: &'static [u8; 8usize] = b"Inexact\0";
pub const DEC_Condition_IS: &'static [u8; 21usize] = b"Insufficient storage\0";
pub const DEC_Condition_IC: &'static [u8; 16usize] = b"Invalid context\0";
pub const DEC_Condition_IO: &'static [u8; 18usize] = b"Invalid operation\0";
pub const DEC_Condition_OV: &'static [u8; 9usize] = b"Overflow\0";
pub const DEC_Condition_PA: &'static [u8; 8usize] = b"Clamped\0";
pub const DEC_Condition_RO: &'static [u8; 8usize] = b"Rounded\0";
pub const DEC_Condition_SU: &'static [u8; 10usize] = b"Subnormal\0";
pub const DEC_Condition_UN: &'static [u8; 10usize] = b"Underflow\0";
pub const DEC_Condition_ZE: &'static [u8; 10usize] = b"No status\0";
pub const DEC_Condition_MU: &'static [u8; 16usize] = b"Multiple status\0";
pub const DEC_Condition_Length: u32 = 21;
pub const DEC_INIT_BASE: u32 = 0;
pub const DEC_INIT_DECIMAL32: u32 = 32;
pub const DEC_INIT_DECIMAL64: u32 = 64;
pub const DEC_INIT_DECIMAL128: u32 = 128;
pub const DEC_INIT_DECSINGLE: u32 = 32;
pub const DEC_INIT_DECDOUBLE: u32 = 64;
pub const DEC_INIT_DECQUAD: u32 = 128;
pub const DECFLOAT_Sign: u32 = 2147483648;
pub const DECFLOAT_NaN: u32 = 2080374784;
pub const DECFLOAT_qNaN: u32 = 2080374784;
pub const DECFLOAT_sNaN: u32 = 2113929216;
pub const DECFLOAT_Inf: u32 = 2013265920;
pub const DECFLOAT_MinSp: u32 = 2013265920;
pub const DECPPLUSALT: u32 = 10;
pub const DECPMINUSALT: u32 = 11;
pub const DECPPLUS: u32 = 12;
pub const DECPMINUS: u32 = 13;
pub const DECPPLUSALT2: u32 = 14;
pub const DECPUNSIGNED: u32 = 15;
pub const DECNAME: &'static [u8; 10usize] = b"decNumber\0";
pub const DECFULLNAME: &'static [u8; 22usize] = b"Decimal Number Module\0";
pub const DECAUTHOR: &'static [u8; 15usize] = b"Mike Cowlishaw\0";
pub const DECNEG: u32 = 128;
pub const DECINF: u32 = 64;
pub const DECNAN: u32 = 32;
pub const DECSNAN: u32 = 16;
pub const DECSPECIAL: u32 = 112;
pub const DECDPUN: u32 = 3;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const MAX_INT32: u32 = 2147483647;
pub const MIN_INT32: i32 = -2147483648;
pub const MAX_INT64: u64 = 9223372036854775807;
pub const MIN_INT64: i64 = -9223372036854775808;
pub const tid_none_INT: i32 = -512;
pub const tid_EOF_INT: i32 = -256;
pub const tid_NULL_INT: u32 = 0;
pub const tid_BOOL_INT: u32 = 256;
pub const tid_INT_INT: u32 = 512;
pub const tid_FLOAT_INT: u32 = 1024;
pub const tid_DECIMAL_INT: u32 = 1280;
pub const tid_TIMESTAMP_INT: u32 = 1536;
pub const tid_SYMBOL_INT: u32 = 1792;
pub const tid_STRING_INT: u32 = 2048;
pub const tid_CLOB_INT: u32 = 2304;
pub const tid_BLOB_INT: u32 = 2560;
pub const tid_LIST_INT: u32 = 2816;
pub const tid_SEXP_INT: u32 = 3072;
pub const tid_STRUCT_INT: u32 = 3328;
pub const tid_DATAGRAM_INT: u32 = 3840;
pub const MAX_SIZE: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const DEFAULT_STRING_LENGTH: u32 = 8;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const ION_TT_BIT_YEAR: u32 = 1;
pub const ION_TT_BIT_MONTH: u32 = 2;
pub const ION_TT_BIT_DAY: u32 = 4;
pub const ION_TT_BIT_MIN: u32 = 16;
pub const ION_TT_BIT_SEC: u32 = 32;
pub const ION_TT_BIT_FRAC: u32 = 64;
pub const ION_TS_YEAR: u32 = 1;
pub const ION_TS_MONTH: u32 = 3;
pub const ION_TS_DAY: u32 = 7;
pub const ION_TS_MIN: u32 = 23;
pub const ION_TS_SEC: u32 = 55;
pub const ION_TS_FRAC: u32 = 119;
pub const ION_MAX_TIMESTAMP_STRING: u32 = 69;
pub const II_PLUS: u8 = 43u8;
pub const II_MINUS: u8 = 45u8;
pub const II_STRING_BASE: u32 = 10;
pub const II_BITS_PER_DEC_DIGIT: f64 = 3.35;
pub const II_DEC_DIGIT_PER_BITS: f64 = 3.32191780821918;
pub const II_II_DIGITS_PER_DEC_DIGIT: f64 = 0.108064516;
pub const II_DEC_DIGITS_PER_II_DIGIT: f64 = 9.253731343;
pub const II_BITS_PER_HEX_DIGIT: u32 = 4;
pub const II_HEX_BASE: u32 = 16;
pub const II_HEX_RADIX_CHARS: &'static [u8; 3usize] = b"xX\0";
pub const II_BITS_PER_BINARY_DIGIT: u32 = 1;
pub const II_BINARY_BASE: u32 = 2;
pub const II_BINARY_RADIX_CHARS: &'static [u8; 3usize] = b"bB\0";
pub const II_BITS_PER_BYTE: u32 = 8;
pub const II_BYTE_BASE: u32 = 256;
pub const II_BYTE_MASK: u32 = 255;
pub const II_BYTE_SIGN_BIT: u32 = 128;
pub const II_BYTE_NEG_OVERFLOW_LIMIT: u32 = 254;
pub const UNKNOWN_SID: i32 = -1;
pub const ION_SYS_SYMBOL_SHARED_SYMBOL_TABLE: &'static [u8; 25usize] =
    b"$ion_shared_symbol_table\0";
pub const ION_SYS_STRLEN_SHARED_SYMBOL_TABLE: u32 = 24;
pub const ION_SYS_SYMBOL_ION: &'static [u8; 5usize] = b"$ion\0";
pub const ION_SYS_SYMBOL_IVM: &'static [u8; 9usize] = b"$ion_1_0\0";
pub const ION_SYS_SYMBOL_ION_SYMBOL_TABLE: &'static [u8; 18usize] = b"$ion_symbol_table\0";
pub const ION_SYS_SYMBOL_NAME: &'static [u8; 5usize] = b"name\0";
pub const ION_SYS_SYMBOL_VERSION: &'static [u8; 8usize] = b"version\0";
pub const ION_SYS_SYMBOL_IMPORTS: &'static [u8; 8usize] = b"imports\0";
pub const ION_SYS_SYMBOL_SYMBOLS: &'static [u8; 8usize] = b"symbols\0";
pub const ION_SYS_SYMBOL_MAX_ID: &'static [u8; 7usize] = b"max_id\0";
pub const ION_SYS_SYMBOL_MAX_ID_UNDEFINED: i32 = -1;
pub const ION_SYS_SID_ION: u32 = 1;
pub const ION_SYS_SID_IVM: u32 = 2;
pub const ION_SYS_SID_SYMBOL_TABLE: u32 = 3;
pub const ION_SYS_SID_NAME: u32 = 4;
pub const ION_SYS_SID_VERSION: u32 = 5;
pub const ION_SYS_SID_IMPORTS: u32 = 6;
pub const ION_SYS_SID_SYMBOLS: u32 = 7;
pub const ION_SYS_SID_MAX_ID: u32 = 8;
pub const ION_SYS_SID_SHARED_SYMBOL_TABLE: u32 = 9;
pub const ION_SYS_STRLEN_ION: u32 = 4;
pub const ION_SYS_STRLEN_IVM: u32 = 8;
pub const ION_SYS_STRLEN_SYMBOL_TABLE: u32 = 17;
pub const ION_SYS_STRLEN_NAME: u32 = 4;
pub const ION_SYS_STRLEN_VERSION: u32 = 7;
pub const ION_SYS_STRLEN_IMPORTS: u32 = 7;
pub const ION_SYS_STRLEN_SYMBOLS: u32 = 7;
pub const ION_SYS_STRLEN_MAX_ID: u32 = 6;
pub const ION_ERROR_MESSAGE_MAX_LENGTH: u32 = 1024;
pub const ION_TIMESTAMP_STRING_LENGTH: u32 = 55;
pub const ION_VERSION_MARKER_LENGTH: u32 = 4;
pub const ion_error_code_IERR_NOT_IMPL: ion_error_code = -1;
pub const ion_error_code_IERR_OK: ion_error_code = 0;
pub const ion_error_code_IERR_BAD_HANDLE: ion_error_code = 1;
pub const ion_error_code_IERR_INVALID_ARG: ion_error_code = 2;
pub const ion_error_code_IERR_NO_MEMORY: ion_error_code = 3;
pub const ion_error_code_IERR_EOF: ion_error_code = 4;
pub const ion_error_code_IERR_INVALID_STATE: ion_error_code = 5;
pub const ion_error_code_IERR_TOO_MANY_ANNOTATIONS: ion_error_code = 6;
pub const ion_error_code_IERR_UNRECOGNIZED_FLOAT: ion_error_code = 7;
pub const ion_error_code_IERR_NULL_VALUE: ion_error_code = 8;
pub const ion_error_code_IERR_BUFFER_TOO_SMALL: ion_error_code = 9;
pub const ion_error_code_IERR_INVALID_TIMESTAMP: ion_error_code = 10;
pub const ion_error_code_IERR_INVALID_UNICODE_SEQUENCE: ion_error_code = 12;
pub const ion_error_code_IERR_UNREAD_LIMIT_EXCEEDED: ion_error_code = 13;
pub const ion_error_code_IERR_INVALID_TOKEN: ion_error_code = 14;
pub const ion_error_code_IERR_INVALID_UTF8: ion_error_code = 15;
pub const ion_error_code_IERR_LOOKAHEAD_OVERFLOW: ion_error_code = 16;
pub const ion_error_code_IERR_BAD_BASE64_BLOB: ion_error_code = 17;
pub const ion_error_code_IERR_TOKEN_TOO_LONG: ion_error_code = 18;
pub const ion_error_code_IERR_INVALID_UTF8_CHAR: ion_error_code = 19;
pub const ion_error_code_IERR_UNEXPECTED_EOF: ion_error_code = 20;
pub const ion_error_code_IERR_INVALID_ESCAPE_SEQUENCE: ion_error_code = 21;
pub const ion_error_code_IERR_INVALID_SYNTAX: ion_error_code = 22;
pub const ion_error_code_IERR_INVALID_TOKEN_CHAR: ion_error_code = 23;
pub const ion_error_code_IERR_INVALID_SYMBOL: ion_error_code = 24;
pub const ion_error_code_IERR_STACK_UNDERFLOW: ion_error_code = 25;
pub const ion_error_code_IERR_INVALID_SYMBOL_LIST: ion_error_code = 26;
pub const ion_error_code_IERR_PARSER_INTERNAL: ion_error_code = 27;
pub const ion_error_code_IERR_INVALID_SYMBOL_TABLE: ion_error_code = 28;
pub const ion_error_code_IERR_IS_IMMUTABLE: ion_error_code = 29;
pub const ion_error_code_IERR_DUPLICATE_SYMBOL: ion_error_code = 30;
pub const ion_error_code_IERR_DUPLICATE_SYMBOL_ID: ion_error_code = 31;
pub const ion_error_code_IERR_NO_SUCH_ELEMENT: ion_error_code = 32;
pub const ion_error_code_IERR_INVALID_FIELDNAME: ion_error_code = 33;
pub const ion_error_code_IERR_INVALID_BINARY: ion_error_code = 34;
pub const ion_error_code_IERR_IMPORT_NOT_FOUND: ion_error_code = 35;
pub const ion_error_code_IERR_NUMERIC_OVERFLOW: ion_error_code = 36;
pub const ion_error_code_IERR_INVALID_ION_VERSION: ion_error_code = 37;
pub const ion_error_code_IERR_ENTRY_NOT_FOUND: ion_error_code = 38;
pub const ion_error_code_IERR_CANT_FIND_FILE: ion_error_code = 39;
pub const ion_error_code_IERR_STREAM_FAILED: ion_error_code = 40;
pub const ion_error_code_IERR_KEY_ALREADY_EXISTS: ion_error_code = 41;
pub const ion_error_code_IERR_KEY_NOT_FOUND: ion_error_code = 42;
pub const ion_error_code_IERR_KEY_ADDED: ion_error_code = 43;
pub const ion_error_code_IERR_HAS_LOCAL_SYMBOLS: ion_error_code = 44;
pub const ion_error_code_IERR_NOT_A_SYMBOL_TABLE: ion_error_code = 45;
pub const ion_error_code_IERR_MARK_NOT_SET: ion_error_code = 46;
pub const ion_error_code_IERR_WRITE_ERROR: ion_error_code = 47;
pub const ion_error_code_IERR_SEEK_ERROR: ion_error_code = 48;
pub const ion_error_code_IERR_READ_ERROR: ion_error_code = 49;
pub const ion_error_code_IERR_INTERNAL_ERROR: ion_error_code = 50;
pub const ion_error_code_IERR_NEW_LINE_IN_STRING: ion_error_code = 51;
pub const ion_error_code_IERR_INVALID_LEADING_ZEROS: ion_error_code = 52;
pub const ion_error_code_IERR_INVALID_LOB_TERMINATOR: ion_error_code = 53;
pub const ion_error_code_IERR_MAX_ERROR_CODE: ion_error_code = 54;
#[doc = " define the Ion error code enumeration."]
#[doc = ""]
pub type ion_error_code = ::std::os::raw::c_int;
pub use self::ion_error_code as iERR;
extern "C" {
    #[doc = " Gets a static string representation of an error code."]
    pub fn ion_error_to_str(err: iERR) -> *const ::std::os::raw::c_char;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
pub type size_t = __darwin_size_t;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
impl Default for __sbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
impl Default for __sFILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
impl Default for __darwin_zmm_reg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
impl Default for __darwin_i386_float_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
impl Default for __darwin_i386_avx_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
impl Default for __darwin_i386_avx512_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __x86_instruction_state {
    pub __insn_stream_valid_bytes: ::std::os::raw::c_int,
    pub __insn_offset: ::std::os::raw::c_int,
    pub __out_of_synch: ::std::os::raw::c_int,
    pub __insn_bytes: [__uint8_t; 2380usize],
    pub __insn_cacheline: [__uint8_t; 64usize],
}
#[test]
fn bindgen_test_layout___x86_instruction_state() {
    assert_eq!(
        ::std::mem::size_of::<__x86_instruction_state>(),
        2456usize,
        concat!("Size of: ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_instruction_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_stream_valid_bytes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_stream_valid_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__out_of_synch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__out_of_synch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_bytes as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_cacheline as *const _
                as usize
        },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_cacheline)
        )
    );
}
impl Default for __x86_instruction_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __last_branch_record {
    pub __from_ip: __uint64_t,
    pub __to_ip: __uint64_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout___last_branch_record() {
    assert_eq!(
        ::std::mem::size_of::<__last_branch_record>(),
        24usize,
        concat!("Size of: ", stringify!(__last_branch_record))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_record>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_record>())).__from_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__from_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_record>())).__to_ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__to_ip)
        )
    );
}
impl __last_branch_record {
    #[inline]
    pub fn __mispredict(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___mispredict(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tsx_abort(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___tsx_abort(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __in_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___in_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set___cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __mispredict: __uint32_t,
        __tsx_abort: __uint32_t,
        __in_tsx: __uint32_t,
        __cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __mispredict: u32 = unsafe { ::std::mem::transmute(__mispredict) };
            __mispredict as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __tsx_abort: u32 = unsafe { ::std::mem::transmute(__tsx_abort) };
            __tsx_abort as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __in_tsx: u32 = unsafe { ::std::mem::transmute(__in_tsx) };
            __in_tsx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 16u8, {
            let __cycle_count: u32 = unsafe { ::std::mem::transmute(__cycle_count) };
            __cycle_count as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __last_branch_state {
    pub __lbr_count: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __lbrs: [__last_branch_record; 32usize],
}
#[test]
fn bindgen_test_layout___last_branch_state() {
    assert_eq!(
        ::std::mem::size_of::<__last_branch_state>(),
        776usize,
        concat!("Size of: ", stringify!(__last_branch_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_state>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_state>())).__lbr_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbr_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_state>())).__lbrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbrs)
        )
    );
}
impl __last_branch_state {
    #[inline]
    pub fn __lbr_supported_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __lbr_supported_cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __lbr_supported_tsx: __uint32_t,
        __lbr_supported_cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __lbr_supported_tsx: u32 = unsafe { ::std::mem::transmute(__lbr_supported_tsx) };
            __lbr_supported_tsx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __lbr_supported_cycle_count: u32 =
                unsafe { ::std::mem::transmute(__lbr_supported_cycle_count) };
            __lbr_supported_cycle_count as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __x86_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___x86_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__x86_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_pagein_state>())).__pagein_error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_thread_full_state64 {
    pub __ss64: __darwin_x86_thread_state64,
    pub __ds: __uint64_t,
    pub __es: __uint64_t,
    pub __ss: __uint64_t,
    pub __gsbase: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_full_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_full_state64>(),
        200usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_full_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_full_state64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_x86_thread_full_state64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ss64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ds as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__es as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ss as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__gsbase as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__gsbase)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
impl Default for __darwin_x86_float_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
impl Default for __darwin_x86_avx_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
impl Default for __darwin_x86_avx512_state64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx512_32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64_full>(),
        744usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext64_full {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),
        1064usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx64_full {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx512_64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64_full>(),
        2664usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64_full>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_mcontext_avx512_64_full)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__fs as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__fs)
        )
    );
}
impl Default for __darwin_mcontext_avx512_64_full {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
impl Default for __darwin_ucontext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ucontext_t = __darwin_ucontext;
pub type pid_t = __darwin_pid_t;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
impl Default for sigevent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __siginfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
impl Default for __sigaction_u {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl Default for __sigaction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
impl Default for sigaction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
impl Default for sigstack {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type pthread_t = __darwin_pthread_t;
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
pub const rounding_DEC_ROUND_CEILING: rounding = 0;
pub const rounding_DEC_ROUND_UP: rounding = 1;
pub const rounding_DEC_ROUND_HALF_UP: rounding = 2;
pub const rounding_DEC_ROUND_HALF_EVEN: rounding = 3;
pub const rounding_DEC_ROUND_HALF_DOWN: rounding = 4;
pub const rounding_DEC_ROUND_DOWN: rounding = 5;
pub const rounding_DEC_ROUND_FLOOR: rounding = 6;
pub const rounding_DEC_ROUND_05UP: rounding = 7;
pub const rounding_DEC_ROUND_MAX: rounding = 8;
pub type rounding = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decContext {
    pub digits: i32,
    pub emax: i32,
    pub emin: i32,
    pub round: rounding,
    pub traps: u32,
    pub status: u32,
    pub clamp: u8,
}
#[test]
fn bindgen_test_layout_decContext() {
    assert_eq!(
        ::std::mem::size_of::<decContext>(),
        28usize,
        concat!("Size of: ", stringify!(decContext))
    );
    assert_eq!(
        ::std::mem::align_of::<decContext>(),
        4usize,
        concat!("Alignment of ", stringify!(decContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).digits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).emax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(emax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).emin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(emin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).round as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(round)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).traps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(traps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decContext>())).clamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(decContext),
            "::",
            stringify!(clamp)
        )
    );
}
impl Default for decContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const decClass_DEC_CLASS_SNAN: decClass = 0;
pub const decClass_DEC_CLASS_QNAN: decClass = 1;
pub const decClass_DEC_CLASS_NEG_INF: decClass = 2;
pub const decClass_DEC_CLASS_NEG_NORMAL: decClass = 3;
pub const decClass_DEC_CLASS_NEG_SUBNORMAL: decClass = 4;
pub const decClass_DEC_CLASS_NEG_ZERO: decClass = 5;
pub const decClass_DEC_CLASS_POS_ZERO: decClass = 6;
pub const decClass_DEC_CLASS_POS_SUBNORMAL: decClass = 7;
pub const decClass_DEC_CLASS_POS_NORMAL: decClass = 8;
pub const decClass_DEC_CLASS_POS_INF: decClass = 9;
pub type decClass = ::std::os::raw::c_uint;
extern "C" {
    pub fn decContextClearStatus(arg1: *mut decContext, arg2: u32) -> *mut decContext;
}
extern "C" {
    pub fn decContextDefault(arg1: *mut decContext, arg2: i32) -> *mut decContext;
}
extern "C" {
    pub fn decContextGetRounding(arg1: *mut decContext) -> rounding;
}
extern "C" {
    pub fn decContextGetStatus(arg1: *mut decContext) -> u32;
}
extern "C" {
    pub fn decContextRestoreStatus(arg1: *mut decContext, arg2: u32, arg3: u32) -> *mut decContext;
}
extern "C" {
    pub fn decContextSaveStatus(arg1: *mut decContext, arg2: u32) -> u32;
}
extern "C" {
    pub fn decContextSetRounding(arg1: *mut decContext, arg2: rounding) -> *mut decContext;
}
extern "C" {
    pub fn decContextSetStatus(arg1: *mut decContext, arg2: u32) -> *mut decContext;
}
extern "C" {
    pub fn decContextSetStatusFromString(
        arg1: *mut decContext,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut decContext;
}
extern "C" {
    pub fn decContextSetStatusFromStringQuiet(
        arg1: *mut decContext,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut decContext;
}
extern "C" {
    pub fn decContextSetStatusQuiet(arg1: *mut decContext, arg2: u32) -> *mut decContext;
}
extern "C" {
    pub fn decContextStatusToString(arg1: *const decContext) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn decContextTestEndian(arg1: u8) -> i32;
}
extern "C" {
    pub fn decContextTestSavedStatus(arg1: u32, arg2: u32) -> u32;
}
extern "C" {
    pub fn decContextTestStatus(arg1: *mut decContext, arg2: u32) -> u32;
}
extern "C" {
    pub fn decContextZeroStatus(arg1: *mut decContext) -> *mut decContext;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union decQuad {
    pub bytes: [u8; 16usize],
    pub shorts: [u16; 8usize],
    pub words: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_decQuad() {
    assert_eq!(
        ::std::mem::size_of::<decQuad>(),
        16usize,
        concat!("Size of: ", stringify!(decQuad))
    );
    assert_eq!(
        ::std::mem::align_of::<decQuad>(),
        4usize,
        concat!("Alignment of ", stringify!(decQuad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decQuad>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decQuad),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decQuad>())).shorts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decQuad),
            "::",
            stringify!(shorts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decQuad>())).words as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decQuad),
            "::",
            stringify!(words)
        )
    );
}
impl Default for decQuad {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn decQuadFromBCD(
        arg1: *mut decQuad,
        arg2: i32,
        arg3: *const u8,
        arg4: i32,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFromInt32(arg1: *mut decQuad, arg2: i32) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFromPacked(arg1: *mut decQuad, arg2: i32, arg3: *const u8) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFromPackedChecked(arg1: *mut decQuad, arg2: i32, arg3: *const u8)
        -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFromString(
        arg1: *mut decQuad,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFromUInt32(arg1: *mut decQuad, arg2: u32) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadGetCoefficient(arg1: *const decQuad, arg2: *mut u8) -> i32;
}
extern "C" {
    pub fn decQuadGetExponent(arg1: *const decQuad) -> i32;
}
extern "C" {
    pub fn decQuadSetCoefficient(arg1: *mut decQuad, arg2: *const u8, arg3: i32) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadSetExponent(arg1: *mut decQuad, arg2: *mut decContext, arg3: i32)
        -> *mut decQuad;
}
extern "C" {
    pub fn decQuadShow(arg1: *const decQuad, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn decQuadToBCD(arg1: *const decQuad, arg2: *mut i32, arg3: *mut u8) -> i32;
}
extern "C" {
    pub fn decQuadToEngString(
        arg1: *const decQuad,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decQuadToInt32(arg1: *const decQuad, arg2: *mut decContext, arg3: rounding) -> i32;
}
extern "C" {
    pub fn decQuadToInt32Exact(arg1: *const decQuad, arg2: *mut decContext, arg3: rounding) -> i32;
}
extern "C" {
    pub fn decQuadToPacked(arg1: *const decQuad, arg2: *mut i32, arg3: *mut u8) -> i32;
}
extern "C" {
    pub fn decQuadToString(
        arg1: *const decQuad,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decQuadToUInt32(arg1: *const decQuad, arg2: *mut decContext, arg3: rounding) -> u32;
}
extern "C" {
    pub fn decQuadToUInt32Exact(arg1: *const decQuad, arg2: *mut decContext, arg3: rounding)
        -> u32;
}
extern "C" {
    pub fn decQuadZero(arg1: *mut decQuad) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadAbs(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadAdd(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadAnd(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadDivide(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadDivideInteger(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadFMA(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *const decQuad,
        arg5: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadInvert(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadLogB(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMax(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMaxMag(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMin(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMinMag(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMinus(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadMultiply(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadNextMinus(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadNextPlus(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadNextToward(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadOr(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadPlus(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadQuantize(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadReduce(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadRemainder(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadRemainderNear(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadRotate(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadScaleB(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadShift(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadSubtract(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadToIntegralValue(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
        arg4: rounding,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadToIntegralExact(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadXor(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCompare(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCompareSignal(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
        arg4: *mut decContext,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCompareTotal(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCompareTotalMag(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCanonical(arg1: *mut decQuad, arg2: *const decQuad) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCopy(arg1: *mut decQuad, arg2: *const decQuad) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCopyAbs(arg1: *mut decQuad, arg2: *const decQuad) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCopyNegate(arg1: *mut decQuad, arg2: *const decQuad) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadCopySign(
        arg1: *mut decQuad,
        arg2: *const decQuad,
        arg3: *const decQuad,
    ) -> *mut decQuad;
}
extern "C" {
    pub fn decQuadClass(arg1: *const decQuad) -> decClass;
}
extern "C" {
    pub fn decQuadClassString(arg1: *const decQuad) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn decQuadDigits(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsCanonical(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsFinite(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsInteger(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsLogical(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsInfinite(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsNaN(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsNegative(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsNormal(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsPositive(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsSignaling(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsSignalling(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsSigned(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsSubnormal(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadIsZero(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadRadix(arg1: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadSameQuantum(arg1: *const decQuad, arg2: *const decQuad) -> u32;
}
extern "C" {
    pub fn decQuadVersion() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct decNumber {
    pub digits: i32,
    pub exponent: i32,
    pub bits: u8,
    pub lsu: [u16; 12usize],
}
#[test]
fn bindgen_test_layout_decNumber() {
    assert_eq!(
        ::std::mem::size_of::<decNumber>(),
        36usize,
        concat!("Size of: ", stringify!(decNumber))
    );
    assert_eq!(
        ::std::mem::align_of::<decNumber>(),
        4usize,
        concat!("Alignment of ", stringify!(decNumber))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decNumber>())).digits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(decNumber),
            "::",
            stringify!(digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decNumber>())).exponent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(decNumber),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decNumber>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(decNumber),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<decNumber>())).lsu as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(decNumber),
            "::",
            stringify!(lsu)
        )
    );
}
extern "C" {
    pub fn decNumberFromInt32(arg1: *mut decNumber, arg2: i32) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberFromUInt32(arg1: *mut decNumber, arg2: u32) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberFromString(
        arg1: *mut decNumber,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberToString(
        arg1: *const decNumber,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decNumberToEngString(
        arg1: *const decNumber,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decNumberToUInt32(arg1: *const decNumber, arg2: *mut decContext) -> u32;
}
extern "C" {
    pub fn decNumberToInt32(arg1: *const decNumber, arg2: *mut decContext) -> i32;
}
extern "C" {
    pub fn decNumberGetBCD(arg1: *const decNumber, arg2: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn decNumberSetBCD(arg1: *mut decNumber, arg2: *const u8, arg3: u32) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberAbs(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberAdd(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberAnd(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCompare(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCompareSignal(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCompareTotal(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCompareTotalMag(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberDivide(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberDivideInteger(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberExp(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberFMA(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *const decNumber,
        arg5: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberInvert(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberLn(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberLogB(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberLog10(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMax(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMaxMag(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMin(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMinMag(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMinus(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberMultiply(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberNormalize(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberOr(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberPlus(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberPower(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberQuantize(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberReduce(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberRemainder(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberRemainderNear(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberRescale(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberRotate(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberSameQuantum(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberScaleB(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberShift(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberSquareRoot(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberSubtract(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberToIntegralExact(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberToIntegralValue(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberXor(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberClass(arg1: *const decNumber, arg2: *mut decContext) -> decClass;
}
extern "C" {
    pub fn decNumberClassToString(arg1: decClass) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn decNumberCopy(arg1: *mut decNumber, arg2: *const decNumber) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCopyAbs(arg1: *mut decNumber, arg2: *const decNumber) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCopyNegate(arg1: *mut decNumber, arg2: *const decNumber) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberCopySign(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberNextMinus(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberNextPlus(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberNextToward(
        arg1: *mut decNumber,
        arg2: *const decNumber,
        arg3: *const decNumber,
        arg4: *mut decContext,
    ) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberTrim(arg1: *mut decNumber) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn decNumberZero(arg1: *mut decNumber) -> *mut decNumber;
}
extern "C" {
    pub fn decNumberIsNormal(arg1: *const decNumber, arg2: *mut decContext) -> i32;
}
extern "C" {
    pub fn decNumberIsSubnormal(arg1: *const decNumber, arg2: *mut decContext) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ion_type {
    _unused: [u8; 0],
}
#[doc = " Strong typed enum over pointer type."]
pub type ION_TYPE = *mut ion_type;
pub type SID = i32;
pub type SIZE = i32;
pub type BYTE = u8;
pub type BOOL = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_symbol_table {
    _unused: [u8; 0],
}
pub type ION_SYMBOL_TABLE = _ion_symbol_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_catalog {
    _unused: [u8; 0],
}
pub type ION_CATALOG = _ion_catalog;
#[doc = " An Ion String."]
#[doc = ""]
#[doc = " @see _ion_string"]
pub type ION_STRING = _ion_string;
pub type ION_SYMBOL = _ion_symbol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_symbol_table_import_descriptor {
    _unused: [u8; 0],
}
pub type ION_SYMBOL_TABLE_IMPORT_DESCRIPTOR = _ion_symbol_table_import_descriptor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_symbol_table_import {
    _unused: [u8; 0],
}
pub type ION_SYMBOL_TABLE_IMPORT = _ion_symbol_table_import;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_reader {
    _unused: [u8; 0],
}
pub type ION_READER = _ion_reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_writer {
    _unused: [u8; 0],
}
pub type ION_WRITER = _ion_writer;
pub type ION_INT = _ion_int;
pub type ION_DECIMAL = _ion_decimal;
pub type ION_TIMESTAMP = _ion_timestamp;
pub type ION_COLLECTION = _ion_collection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_stream {
    _unused: [u8; 0],
}
pub type ION_STREAM = _ion_stream;
pub type ION_STREAM_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(pstream: *mut _ion_user_stream) -> iERR>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_user_stream {
    pub curr: *mut BYTE,
    pub limit: *mut BYTE,
    pub handler_state: *mut ::std::os::raw::c_void,
    pub handler: ION_STREAM_HANDLER,
}
#[test]
fn bindgen_test_layout__ion_user_stream() {
    assert_eq!(
        ::std::mem::size_of::<_ion_user_stream>(),
        32usize,
        concat!("Size of: ", stringify!(_ion_user_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_user_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_user_stream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_user_stream>())).curr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_user_stream),
            "::",
            stringify!(curr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_user_stream>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_user_stream),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_user_stream>())).handler_state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_user_stream),
            "::",
            stringify!(handler_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_user_stream>())).handler as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_user_stream),
            "::",
            stringify!(handler)
        )
    );
}
impl Default for _ion_user_stream {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type iSTRING = *mut ION_STRING;
pub type iSYMBOL = *mut ION_SYMBOL;
pub type iIMPORT = *mut ION_SYMBOL_TABLE_IMPORT;
pub type iSYMTAB = *mut ION_SYMBOL_TABLE;
pub type iCATALOG = *mut ION_CATALOG;
pub type iSTREAM = *mut ION_STREAM;
pub type iTIMESTAMP = *mut ION_TIMESTAMP;
pub type hOWNER = *mut ::std::os::raw::c_void;
pub type hREADER = *mut ION_READER;
pub type hWRITER = *mut ION_WRITER;
pub type hSYMTAB = *mut ION_SYMBOL_TABLE;
pub type hCATALOG = *mut ION_CATALOG;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_string {
    #[doc = "< The number of bytes in the value array."]
    pub length: i32,
    #[doc = "< UTF-8 encoded text, not null-terminated."]
    pub value: *mut BYTE,
}
#[test]
fn bindgen_test_layout__ion_string() {
    assert_eq!(
        ::std::mem::size_of::<_ion_string>(),
        16usize,
        concat!("Size of: ", stringify!(_ion_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_string>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_string),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_string>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_string),
            "::",
            stringify!(value)
        )
    );
}
impl Default for _ion_string {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn ion_string_init(str_: *mut ION_STRING);
}
extern "C" {
    pub fn ion_string_assign(dst: *mut ION_STRING, src: *mut ION_STRING);
}
extern "C" {
    pub fn ion_string_assign_cstr(
        str_: *mut ION_STRING,
        val: *mut ::std::os::raw::c_char,
        len: SIZE,
    ) -> *mut ION_STRING;
}
extern "C" {
    pub fn ion_string_strdup(p_ionstring: *mut ION_STRING) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ion_string_copy_to_owner(
        owner: hOWNER,
        dst: *mut ION_STRING,
        src: *mut ION_STRING,
    ) -> iERR;
}
extern "C" {
    #[doc = " Gets the number of UTF-8 bytes held by the string."]
    #[doc = ""]
    #[doc = " @param str must not be null."]
    #[doc = ""]
    #[doc = " @return may be zero."]
    pub fn ion_string_get_length(str_: *mut ION_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns -1 is idx is out of range or str is null"]
    pub fn ion_string_get_byte(str_: *mut ION_STRING, idx: ::std::os::raw::c_int) -> BYTE;
}
extern "C" {
    #[doc = " Gets a pointer to the UTF-8 bytes held by the string."]
    #[doc = " The number of bytes in the string is determined via ion_string_get_length()."]
    #[doc = ""]
    #[doc = " @param str must not be null."]
    #[doc = ""]
    #[doc = " @return a pointer to the first UTF-8 byte in the string; may be null."]
    #[doc = "   The byte sequence is not null-terminated."]
    pub fn ion_string_get_bytes(str_: *mut ION_STRING) -> *mut BYTE;
}
extern "C" {
    pub fn ion_string_is_null(str_: *mut ION_STRING) -> BOOL;
}
extern "C" {
    pub fn ion_string_is_equal(str1: *mut ION_STRING, str2: *mut ION_STRING) -> BOOL;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Structure to store time information."]
#[doc = " time_t only has up to second precision, and time zone support is OS dependent."]
#[doc = " _ion_timestamp uses decimal to store fraction of a second"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ion_timestamp {
    #[doc = " Defined as ION_TS_YEAR, ION_TS_MONTH, ION_TS_DAY, ION_TS_MIN, ION_TS_SEC, ION_TS_FRAC"]
    #[doc = ""]
    pub precision: u8,
    #[doc = " Time zone offset (+/- 24 hours), in term of minutes."]
    #[doc = ""]
    pub tz_offset: i16,
    pub year: u16,
    pub month: u16,
    pub day: u16,
    pub hours: u16,
    pub minutes: u16,
    pub seconds: u16,
    #[doc = " Fraction of a second, e.g: 0.5, 0.01, etc"]
    #[doc = ""]
    pub fraction: decQuad,
}
#[test]
fn bindgen_test_layout__ion_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<_ion_timestamp>(),
        32usize,
        concat!("Size of: ", stringify!(_ion_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(_ion_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).precision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).tz_offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(tz_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).year as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).month as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).hours as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).minutes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).seconds as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_timestamp>())).fraction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_timestamp),
            "::",
            stringify!(fraction)
        )
    );
}
impl Default for _ion_timestamp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Get the time precision for the given timestamp object."]
    #[doc = " The precision values are defined as ION_TS_YEAR, ION_TS_MONTH, ION_TS_DAY,"]
    #[doc = " ION_TS_MIN, ION_TS_SEC and ION_TS_FRAC"]
    #[doc = ""]
    pub fn ion_timestamp_get_precision(
        ptime: *const ION_TIMESTAMP,
        precision: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get the string format of timestamp."]
    #[doc = ""]
    pub fn ion_timestamp_to_string(
        ptime: *mut ION_TIMESTAMP,
        buffer: *mut ::std::os::raw::c_char,
        buf_length: SIZE,
        output_length: *mut SIZE,
        pcontext: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Parse timestamp string and construct timestamp object in ptime."]
    #[doc = "  This expects a null terminated string."]
    #[doc = ""]
    pub fn ion_timestamp_parse(
        ptime: *mut ION_TIMESTAMP,
        buffer: *mut ::std::os::raw::c_char,
        length: SIZE,
        p_characters_used: *mut SIZE,
        pcontext: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified in time_t"]
    #[doc = " time_t can be constructed using time() or mktime(), timegm,"]
    #[doc = " and it contains ION_TS_SEC precision."]
    #[doc = ""]
    #[doc = " Higher precision fields (fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_time_t(ptime: *mut ION_TIMESTAMP, time: *const time_t) -> iERR;
}
extern "C" {
    #[doc = " Fill time_t with value in ION_TIMESTAMP"]
    #[doc = ""]
    pub fn ion_timestamp_to_time_t(ptime: *const ION_TIMESTAMP, time: *mut time_t) -> iERR;
}
extern "C" {
    #[doc = " Comparing two timestamps to see whether they represent the same point in time."]
    #[doc = " Two timestamp of different precision will return false"]
    pub fn ion_timestamp_equals(
        ptime1: *const ION_TIMESTAMP,
        ptime2: *const ION_TIMESTAMP,
        is_equal: *mut BOOL,
        pcontext: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Compare timestamps for instant equality only (i.e. precision and local offsets need not be equivalent)."]
    #[doc = "  NOTE: if this has any use externally, it could be exposed. If not, it should be removed."]
    pub fn ion_timestamp_instant_equals(
        ptime1: *const ION_TIMESTAMP,
        ptime2: *const ION_TIMESTAMP,
        is_equal: *mut BOOL,
        pcontext: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " It will have ION_TS_YEAR precision"]
    #[doc = ""]
    #[doc = " Higher precision fields (month, day, min, sec, fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_year(ptime: *mut ION_TIMESTAMP, year: ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " It will have ION_TS_MONTH precision"]
    #[doc = ""]
    #[doc = " Higher precision fields (day, min, sec, fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_month(
        ptime: *mut ION_TIMESTAMP,
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " It will have ION_TS_DAY precision"]
    #[doc = ""]
    #[doc = " Higher precision fields (min, sec, fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_day(
        ptime: *mut ION_TIMESTAMP,
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " It will have ION_TS_MIN precision"]
    #[doc = ""]
    #[doc = " Higher precision fields (sec, fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_minute(
        ptime: *mut ION_TIMESTAMP,
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
        hours: ::std::os::raw::c_int,
        minutes: ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " It will have ION_TS_SEC precision"]
    #[doc = ""]
    #[doc = " Higher precision field (fraction) will be set to 0."]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_second(
        ptime: *mut ION_TIMESTAMP,
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
        hours: ::std::os::raw::c_int,
        minutes: ::std::os::raw::c_int,
        seconds: ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Initialize ION_TIMESTAMP object with value specified."]
    #[doc = " *p_fraction have a range of (0, 1), not including 0 (without significant digit) and 1."]
    #[doc = " 0.0 (0d-1), 0.00(0d-2) is valid, while 0 or 0. is not."]
    #[doc = ""]
    #[doc = " It will have ION_TS_FRAC precision"]
    #[doc = ""]
    #[doc = " Local time zone will be cleared. ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    pub fn ion_timestamp_for_fraction(
        ptime: *mut ION_TIMESTAMP,
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
        hours: ::std::os::raw::c_int,
        minutes: ::std::os::raw::c_int,
        seconds: ::std::os::raw::c_int,
        p_fraction: *mut decQuad,
        pcontext: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get year"]
    pub fn ion_timestamp_get_thru_year(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get year, month"]
    #[doc = "  If precision is not up to month, 0 will be returned as month value."]
    pub fn ion_timestamp_get_thru_month(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
        p_month: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get year, month, day"]
    #[doc = "  If precision is not up to month/day, 0 will be returned as month/day value."]
    pub fn ion_timestamp_get_thru_day(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
        p_month: *mut ::std::os::raw::c_int,
        p_day: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get time up to minute precision."]
    #[doc = "  If precision is not up to hour/minute, 0 will be returned as hour/minute value."]
    pub fn ion_timestamp_get_thru_minute(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
        p_month: *mut ::std::os::raw::c_int,
        p_day: *mut ::std::os::raw::c_int,
        p_hour: *mut ::std::os::raw::c_int,
        p_minute: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get time up to second precision."]
    #[doc = "  If precision is not up to hour/minute/second, 0 will be returned as hour/minute/second value."]
    pub fn ion_timestamp_get_thru_second(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
        p_month: *mut ::std::os::raw::c_int,
        p_day: *mut ::std::os::raw::c_int,
        p_hour: *mut ::std::os::raw::c_int,
        p_minute: *mut ::std::os::raw::c_int,
        p_second: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Get time up to fraction of second precision."]
    #[doc = "  If precision is not up to fraction, 0 will be returned."]
    pub fn ion_timestamp_get_thru_fraction(
        ptime: *mut ION_TIMESTAMP,
        p_year: *mut ::std::os::raw::c_int,
        p_month: *mut ::std::os::raw::c_int,
        p_day: *mut ::std::os::raw::c_int,
        p_hour: *mut ::std::os::raw::c_int,
        p_minute: *mut ::std::os::raw::c_int,
        p_second: *mut ::std::os::raw::c_int,
        p_fraction: *mut decQuad,
    ) -> iERR;
}
extern "C" {
    #[doc = " Determines whether a timestamp has a defined local offset (for example,"]
    #[doc = " \"+08:00\" or \"Z\".  Otherwise, it's local offest is unknown (\"-00:00\"), and"]
    #[doc = " effectively zero."]
    #[doc = ""]
    #[doc = " @param ptime the timestamp to inspect."]
    #[doc = " @param p_has_local_offset the return value; false when the local offset is"]
    #[doc = "   unknown."]
    #[doc = ""]
    #[doc = " @return IERR_INVALID_ARG if any parameter is null."]
    pub fn ion_timestamp_has_local_offset(
        ptime: *mut ION_TIMESTAMP,
        p_has_local_offset: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    #[doc = " Gets the effective local offset of a timestamp.  The result is zero for"]
    #[doc = " timestamps with offsets \"Z\", \"+00:00\", or \"-00:00\".  In other words, if"]
    #[doc = " ion_timestamp_has_local_offset returns false, this returns zero."]
    #[doc = ""]
    #[doc = " @param ptime the timestamp to inspect."]
    #[doc = " @param p_local_offset the return value, in minutes from GMT;"]
    #[doc = "   zero when the local offset is unknown."]
    #[doc = ""]
    #[doc = " @return IERR_INVALID_ARG if any parameter is null;"]
    #[doc = "   IERR_NULL_VALUE if the timestamp is null.timestamp."]
    pub fn ion_timestamp_get_local_offset(
        ptime: *mut ION_TIMESTAMP,
        p_offset_minutes: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    #[doc = " Removes any local offset from a timestamp."]
    #[doc = " Afterwards, ion_timestamp_has_local_offset will be false, and"]
    #[doc = " ion_timestamp_get_local_offset will be zero."]
    #[doc = ""]
    #[doc = " @param ptime the timestamp to alter."]
    #[doc = ""]
    #[doc = " @return IERR_INVALID_ARG if any parameter is null."]
    pub fn ion_timestamp_unset_local_offset(ptime: *mut ION_TIMESTAMP) -> iERR;
}
extern "C" {
    #[doc = " Changes the local offset of a timestamp. If the timestamp has less than minute precision,"]
    #[doc = " the given offset is ignored and the timestamp is unchanged."]
    #[doc = " If the timestamp is changed, ion_timestamp_has_local_offset will be true, and"]
    #[doc = " ion_timestamp_get_local_offset will be the given offset."]
    #[doc = ""]
    #[doc = " @param ptime the timestamp to alter."]
    #[doc = " @param offset_minutes the new local offset, in (positive or negative)"]
    #[doc = "   minutes from GMT."]
    #[doc = ""]
    #[doc = " @return IERR_INVALID_ARG if ptime is null, or if offset_minutes is outside"]
    #[doc = " the range -23:59 to +23:59."]
    pub fn ion_timestamp_set_local_offset(
        ptime: *mut ION_TIMESTAMP,
        offset_minutes: ::std::os::raw::c_int,
    ) -> iERR;
}
pub const ION_DECIMAL_TYPE_ION_DECIMAL_TYPE_UNKNOWN: ION_DECIMAL_TYPE = 0;
#[doc = " The _ion_decimal holds a decQuad."]
pub const ION_DECIMAL_TYPE_ION_DECIMAL_TYPE_QUAD: ION_DECIMAL_TYPE = 1;
#[doc = " The _ion_decimal holds an unowned decNumber."]
pub const ION_DECIMAL_TYPE_ION_DECIMAL_TYPE_NUMBER: ION_DECIMAL_TYPE = 2;
#[doc = " The _ion_decimal holds a decNumber whose memory is managed by an owner."]
pub const ION_DECIMAL_TYPE_ION_DECIMAL_TYPE_NUMBER_OWNED: ION_DECIMAL_TYPE = 3;
#[doc = " Determines which value of the _ion_decimal's `value` field is active."]
pub type ION_DECIMAL_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ion_decimal {
    pub type_: ION_DECIMAL_TYPE,
    pub value: _ion_decimal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ion_decimal__bindgen_ty_1 {
    pub quad_value: decQuad,
    pub num_value: *mut decNumber,
}
#[test]
fn bindgen_test_layout__ion_decimal__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_ion_decimal__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_ion_decimal__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_decimal__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_decimal__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_decimal__bindgen_ty_1>())).quad_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_decimal__bindgen_ty_1),
            "::",
            stringify!(quad_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_decimal__bindgen_ty_1>())).num_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_decimal__bindgen_ty_1),
            "::",
            stringify!(num_value)
        )
    );
}
impl Default for _ion_decimal__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout__ion_decimal() {
    assert_eq!(
        ::std::mem::size_of::<_ion_decimal>(),
        24usize,
        concat!("Size of: ", stringify!(_ion_decimal))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_decimal>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_decimal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_decimal>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_decimal),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_decimal>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_decimal),
            "::",
            stringify!(value)
        )
    );
}
impl Default for _ion_decimal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Zeroes the given ION_DECIMAL in-place. NOTE: this has better performance than memset in certain environments."]
    #[doc = ""]
    #[doc = " @param value - the value to zero."]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_zero(value: *mut ION_DECIMAL) -> iERR;
}
extern "C" {
    #[doc = " If necessary, copies the given decimal's internal data so that owner of that data may safely go out of scope. This is"]
    #[doc = " useful, for example, when it is necessary to keep the value in scope after the reader that produced it is closed."]
    #[doc = " Values produced through calls to `ion_decimal_*` APIs (with the possible exception of `ion_decimal_from_number`) do"]
    #[doc = " NOT need to be claimed."]
    #[doc = ""]
    #[doc = " @param value - The value to claim."]
    pub fn ion_decimal_claim(value: *mut ION_DECIMAL) -> iERR;
}
extern "C" {
    #[doc = " Frees any memory that was allocated when constructing this value. This should be called to clean up all ION_DECIMALs."]
    #[doc = ""]
    #[doc = " @param value - The value to free."]
    pub fn ion_decimal_free(value: *mut ION_DECIMAL) -> iERR;
}
extern "C" {
    #[doc = " Converts the given ION_DECIMAL to a string. `ION_DECIMAL_STRLEN` may be used to determine the amount of space"]
    #[doc = " required to hold the string representation."]
    #[doc = ""]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_to_string(
        value: *const ION_DECIMAL,
        p_string: *mut ::std::os::raw::c_char,
    ) -> iERR;
}
extern "C" {
    #[doc = " Converts the given string to its ION_DECIMAL representation."]
    #[doc = ""]
    #[doc = " @param value - a non-null pointer to the resulting decimal."]
    #[doc = " @param str - a null-terminated string representing a decimal. Exponents (if any) may be indicated using either 'd'"]
    #[doc = "   or 'e'."]
    #[doc = " @param context - the context to use for the conversion. If the decimal lies outside of the context's limits, an error"]
    #[doc = "   is raised."]
    #[doc = " @return IERR_NUMERIC_OVERFLOW if the decimal lies outside of the context's limits, otherwise IERR_OK."]
    pub fn ion_decimal_from_string(
        value: *mut ION_DECIMAL,
        str_: *const ::std::os::raw::c_char,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = " Represents the given uint32 as an ION_DECIMAL."]
    #[doc = ""]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_from_uint32(value: *mut ION_DECIMAL, num: u32) -> iERR;
}
extern "C" {
    #[doc = " Represents the given int32 as an ION_DECIMAL."]
    #[doc = ""]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_from_int32(value: *mut ION_DECIMAL, num: i32) -> iERR;
}
extern "C" {
    #[doc = " Represents the given decQuad as an ION_DECIMAL. The caller IS NOT required to keep the given decQuad in scope for the"]
    #[doc = " lifetime of the resulting ION_DECIMAL."]
    #[doc = ""]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_from_quad(value: *mut ION_DECIMAL, quad: *mut decQuad) -> iERR;
}
extern "C" {
    #[doc = " Represents the given decNumber as an ION_DECIMAL. This function does not allocate or copy any memory, so the caller"]
    #[doc = " IS required to keep the given decNumber in scope for the lifetime of the resulting ION_DECIMAL. If desired, the"]
    #[doc = " caller can alleviate this requirement by calling `ion_decimal_claim` on the resulting ION_DECIMAL (note that this"]
    #[doc = " forces a copy). It is the caller's responsibility to eventually free any dynamically allocated memory used by the"]
    #[doc = " given decNumber (calling `ion_decimal_free` will not free this memory)."]
    #[doc = ""]
    #[doc = " @return IERR_OK (no errors are possible)."]
    pub fn ion_decimal_from_number(value: *mut ION_DECIMAL, number: *mut decNumber) -> iERR;
}
extern "C" {
    #[doc = " Converts the given ION_INT to its ION_DECIMAL representation."]
    pub fn ion_decimal_from_ion_int(
        value: *mut ION_DECIMAL,
        context: *mut decContext,
        p_int: *mut ION_INT,
    ) -> iERR;
}
extern "C" {
    #[doc = " Converts the given ION_DECIMAL to its ION_INT representation. If the given ION_DECIMAL is not an integer,"]
    #[doc = " IERR_INVALID_ARG will be returned; rounding will never occur. If rounding is desired, use"]
    #[doc = " `ion_decimal_to_integral_exact` or `ion_decimal_to_integral_value` first."]
    pub fn ion_decimal_to_ion_int(
        value: *const ION_DECIMAL,
        context: *mut decContext,
        p_int: *mut ION_INT,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_to_int32(
        value: *const ION_DECIMAL,
        context: *mut decContext,
        p_int: *mut i32,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_to_uint32(
        value: *const ION_DECIMAL,
        context: *mut decContext,
        p_int: *mut u32,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_fma(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        fhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_add(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_and(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_divide(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_divide_integer(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_max(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_max_mag(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_min(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_min_mag(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_multiply(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_or(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_quantize(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_remainder(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_remainder_near(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_rotate(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_scaleb(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_shift(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_subtract(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_xor(
        value: *mut ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_abs(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_invert(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_logb(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_minus(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_plus(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_reduce(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_to_integral_exact(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_to_integral_value(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_digits(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_get_exponent(value: *const ION_DECIMAL) -> i32;
}
extern "C" {
    pub fn ion_decimal_radix(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_same_quantum(lhs: *const ION_DECIMAL, rhs: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_integer(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_subnormal(value: *const ION_DECIMAL, context: *mut decContext) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_normal(value: *const ION_DECIMAL, context: *mut decContext) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_finite(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_infinite(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_nan(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_negative(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_zero(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    pub fn ion_decimal_is_canonical(value: *const ION_DECIMAL) -> u32;
}
extern "C" {
    #[doc = " Compares ION_DECIMALs for ordering and equivalence under the Ion data model. A negative result indicates that `left`"]
    #[doc = " is less than `right`. A positive result indicates that `left` is greater than `right`. A result of zero indicates"]
    #[doc = " that `left` and `right` are equivalent under the Ion data model. Non-equivalent values are ordered according to the"]
    #[doc = " IEEE 754 total ordering."]
    pub fn ion_decimal_compare(
        left: *const ION_DECIMAL,
        right: *const ION_DECIMAL,
        context: *mut decContext,
        result: *mut i32,
    ) -> iERR;
}
extern "C" {
    #[doc = " Compares decQuads for equivalence under the Ion data model. That is, the sign, coefficient, and exponent must be"]
    #[doc = " equivalent for the normalized values (even for zero)."]
    #[doc = ""]
    #[doc = " @deprecated - use of decQuads directly is deprecated. ION_DECIMAL should be used. See `ion_decimal_equals`."]
    pub fn ion_decimal_equals_quad(
        left: *const decQuad,
        right: *const decQuad,
        context: *mut decContext,
        is_equal: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    #[doc = " Compares ION_DECIMALs for equivalence under the Ion data model. That is, the sign, coefficient, and exponent must be"]
    #[doc = " equivalent for the normalized values (even for zero)."]
    pub fn ion_decimal_equals(
        left: *const ION_DECIMAL,
        right: *const ION_DECIMAL,
        context: *mut decContext,
        is_equal: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_decimal_canonical(value: *mut ION_DECIMAL, rhs: *const ION_DECIMAL) -> iERR;
}
extern "C" {
    pub fn ion_decimal_copy(value: *mut ION_DECIMAL, rhs: *const ION_DECIMAL) -> iERR;
}
extern "C" {
    pub fn ion_decimal_copy_abs(value: *mut ION_DECIMAL, rhs: *const ION_DECIMAL) -> iERR;
}
extern "C" {
    pub fn ion_decimal_copy_negate(value: *mut ION_DECIMAL, rhs: *const ION_DECIMAL) -> iERR;
}
extern "C" {
    pub fn ion_decimal_copy_sign(
        value: *mut ION_DECIMAL,
        rhs: *const ION_DECIMAL,
        lhs: *const ION_DECIMAL,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_float_is_negative_zero(value: f64) -> BOOL;
}
pub type II_DIGIT = u32;
pub type II_LONG_DIGIT = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_int {
    pub _owner: *mut ::std::os::raw::c_void,
    pub _signum: ::std::os::raw::c_int,
    pub _len: SIZE,
    pub _digits: *mut II_DIGIT,
}
#[test]
fn bindgen_test_layout__ion_int() {
    assert_eq!(
        ::std::mem::size_of::<_ion_int>(),
        24usize,
        concat!("Size of: ", stringify!(_ion_int))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_int>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_int))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_int>()))._owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_int),
            "::",
            stringify!(_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_int>()))._signum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_int),
            "::",
            stringify!(_signum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_int>()))._len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_int),
            "::",
            stringify!(_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_int>()))._digits as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_int),
            "::",
            stringify!(_digits)
        )
    );
}
impl Default for _ion_int {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub static mut g_int_zero_bytes: [II_DIGIT; 0usize];
}
extern "C" {
    pub static mut g_Int_Zero: ION_INT;
}
extern "C" {
    pub static mut g_Int_Null: ION_INT;
}
extern "C" {
    pub static mut g_ion_int_globals_initialized: BOOL;
}
extern "C" {
    pub static mut g_digit_base_quad: decQuad;
}
extern "C" {
    pub static mut g_digit_base_number: decNumber;
}
extern "C" {
    #[doc = ""]
    pub fn ion_int_alloc(owner: *mut ::std::os::raw::c_void, piint: *mut *mut ION_INT) -> iERR;
}
extern "C" {
    pub fn ion_int_free(iint: *mut ION_INT);
}
extern "C" {
    pub fn ion_int_init(iint: *mut ION_INT, owner: *mut ::std::os::raw::c_void) -> iERR;
}
extern "C" {
    pub fn ion_int_copy(
        dst: *mut ION_INT,
        src: *mut ION_INT,
        owner: *mut ::std::os::raw::c_void,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_is_null(iint: *mut ION_INT, p_is_null: *mut BOOL) -> iERR;
}
extern "C" {
    pub fn ion_int_is_zero(iint: *mut ION_INT, p_bool: *mut BOOL) -> iERR;
}
extern "C" {
    pub fn ion_int_compare(
        left: *mut ION_INT,
        right: *mut ION_INT,
        p_result: *mut ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_signum(iint: *mut ION_INT, p_signum: *mut i32) -> iERR;
}
extern "C" {
    pub fn ion_int_highest_bit_set(iint: *mut ION_INT, p_pos: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_int_from_string(iint: *mut ION_INT, p_str: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_int_from_hex_string(iint: *mut ION_INT, p_str: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_int_from_binary_string(iint: *mut ION_INT, p_str: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_int_from_chars(
        iint: *mut ION_INT,
        p_chars: *const ::std::os::raw::c_char,
        char_limit: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_from_hex_chars(
        iint: *mut ION_INT,
        p_chars: *const ::std::os::raw::c_char,
        char_limit: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_from_binary_chars(
        iint: *mut ION_INT,
        p_chars: *const ::std::os::raw::c_char,
        char_limit: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_from_bytes(iint: *mut ION_INT, buf: *mut BYTE, limit: SIZE) -> iERR;
}
extern "C" {
    pub fn ion_int_from_abs_bytes(
        iint: *mut ION_INT,
        buf: *mut BYTE,
        limit: SIZE,
        is_negative: BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_from_long(iint: *mut ION_INT, value: i64) -> iERR;
}
extern "C" {
    #[doc = " @deprecated use of decQuads directly is deprecated. ION_DECIMAL should be used. See `ion_decimal_to_ion_int`."]
    pub fn ion_int_from_decimal(
        iint: *mut ION_INT,
        p_value: *const decQuad,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_char_length(iint: *mut ION_INT, p_len: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_int_to_char(
        iint: *mut ION_INT,
        p_str: *mut BYTE,
        len: SIZE,
        p_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_to_string(iint: *mut ION_INT, owner: hOWNER, p_str: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_int_byte_length(iint: *mut ION_INT, p_byte_length: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_int_to_bytes(
        iint: *mut ION_INT,
        starting_int_byte_offset: SIZE,
        buffer: *mut BYTE,
        buffer_length: SIZE,
        bytes_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_abs_bytes_length(iint: *mut ION_INT, p_byte_length: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_int_to_abs_bytes(
        iint: *mut ION_INT,
        starting_int_byte_offset: SIZE,
        buffer: *mut BYTE,
        buffer_length: SIZE,
        bytes_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_int_to_int64(iint: *mut ION_INT, p_int64: *mut i64) -> iERR;
}
extern "C" {
    pub fn ion_int_to_int32(iint: *mut ION_INT, p_int32: *mut i32) -> iERR;
}
extern "C" {
    #[doc = " @deprecated use of decQuads directly is deprecated. ION_DECIMAL should be used. See `ion_decimal_from_ion_int`."]
    pub fn ion_int_to_decimal(
        iint: *mut ION_INT,
        p_quad: *mut decQuad,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    #[doc = ""]
    pub fn _ion_int_dump_quad(quad: *mut decQuad, expected: i64);
}
extern "C" {
    pub fn _ion_int_init_globals() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ion_int_from_decimal_number(
        iint: *mut ION_INT,
        p_value: *const decNumber,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_to_decimal_number(
        iint: *mut ION_INT,
        p_value: *mut decNumber,
        context: *mut decContext,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_validate_arg(iint: *const ION_INT) -> iERR;
}
extern "C" {
    pub fn _ion_int_validate_arg_with_ptr(
        iint: *const ION_INT,
        ptr: *const ::std::os::raw::c_void,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_validate_non_null_arg_with_ptr(
        iint: *const ION_INT,
        ptr: *const ::std::os::raw::c_void,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_init(iint: *mut ION_INT, owner: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _ion_int_zero(iint: *mut ION_INT) -> iERR;
}
extern "C" {
    pub fn _ion_int_realloc_helper(
        value: *mut ::std::os::raw::c_void,
        old_len: SIZE,
        owner: *mut ::std::os::raw::c_void,
        new_len: SIZE,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _ion_int_extend_digits(iint: *mut ION_INT, digits_needed: SIZE, zero_fill: BOOL)
        -> iERR;
}
extern "C" {
    pub fn _ion_int_buffer_temp_copy(
        orig_digits: *mut II_DIGIT,
        len: SIZE,
        cache_buffer: *mut II_DIGIT,
        cache_len: SIZE,
    ) -> *mut II_DIGIT;
}
extern "C" {
    pub fn _ion_int_free_temp(temp_buffer: *mut II_DIGIT, cache_buffer: *mut II_DIGIT);
}
extern "C" {
    pub fn _ion_int_from_bytes_helper(
        iint: *mut ION_INT,
        buf: *mut BYTE,
        byte_idx: SIZE,
        limit: SIZE,
        invert: BOOL,
        includes_sign_byte: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn _ion_int_from_chars_helper(
        iint: *mut ION_INT,
        str_: *const ::std::os::raw::c_char,
        len: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_from_radix_chars_helper(
        iint: *mut ION_INT,
        str_: *const ::std::os::raw::c_char,
        len: SIZE,
        digit_values: *mut ::std::os::raw::c_uint,
        base: ::std::os::raw::c_uint,
        bits_per_digit: ::std::os::raw::c_uint,
        radix_chars: *const ::std::os::raw::c_char,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_from_hex_chars_helper(
        iint: *mut ION_INT,
        str_: *const ::std::os::raw::c_char,
        len: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_from_binary_chars_helper(
        iint: *mut ION_INT,
        str_: *const ::std::os::raw::c_char,
        len: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_is_null_helper(iint: *const ION_INT) -> BOOL;
}
extern "C" {
    pub fn _ion_int_is_zero(iint: *const ION_INT) -> BOOL;
}
extern "C" {
    pub fn _ion_int_is_zero_bytes(digits: *const II_DIGIT, len: SIZE) -> BOOL;
}
extern "C" {
    pub fn _ion_int_highest_bit_set_helper(iint: *const ION_INT) -> SIZE;
}
extern "C" {
    pub fn _ion_int_get_char_len_helper(iint: *const ION_INT) -> SIZE;
}
extern "C" {
    pub fn _ion_int_to_string_helper(
        iint: *mut ION_INT,
        strbuf: *mut ::std::os::raw::c_char,
        buflen: SIZE,
        p_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_is_high_bytes_high_bit_set_helper(
        iint: *const ION_INT,
        abs_byte_count: SIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn _ion_int_bytes_length_helper(iint: *const ION_INT) -> SIZE;
}
extern "C" {
    pub fn _ion_int_to_bytes_helper(
        iint: *mut ION_INT,
        bytes_in_int: SIZE,
        starting_int_byte_offset: SIZE,
        is_neg: BOOL,
        buffer: *mut BYTE,
        buffer_length: SIZE,
        bytes_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_abs_bytes_length_helper(iint: *const ION_INT) -> SIZE;
}
extern "C" {
    pub fn _ion_int_abs_bytes_signed_length_helper(iint: *const ION_INT) -> SIZE;
}
extern "C" {
    pub fn _ion_int_to_int64_helper(iint: *mut ION_INT, p_int64: *mut i64) -> iERR;
}
extern "C" {
    pub fn _ion_int_add_digit(digits: *mut II_DIGIT, digit_count: SIZE, value: II_DIGIT) -> iERR;
}
extern "C" {
    pub fn _ion_int_sub_digit(digits: *mut II_DIGIT, digit_count: SIZE, value: II_DIGIT) -> iERR;
}
extern "C" {
    pub fn _ion_int_multiply_and_add(
        digits: *mut II_DIGIT,
        digit_count: SIZE,
        mult_value: II_DIGIT,
        add_value: II_DIGIT,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_int_divide_by_digit(
        digits: *mut II_DIGIT,
        digit_count: SIZE,
        value: II_DIGIT,
        p_remainder: *mut II_DIGIT,
    ) -> iERR;
}
pub type ION_COLLECTION_NODE = _ion_collection_node;
pub type ION_COLLECTION_CURSOR = *mut _ion_collection_node;
#[doc = " The node allocation scheme depends on this layout !"]
#[doc = " currently that there are only 2 members so it uses"]
#[doc = " the size of the ptr as the base to allocate"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_collection_node {
    pub _next: *mut ION_COLLECTION_NODE,
    pub _prev: *mut ION_COLLECTION_NODE,
    pub _data: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__ion_collection_node() {
    assert_eq!(
        ::std::mem::size_of::<_ion_collection_node>(),
        24usize,
        concat!("Size of: ", stringify!(_ion_collection_node))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_collection_node>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_collection_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection_node>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection_node),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection_node>()))._prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection_node),
            "::",
            stringify!(_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection_node>()))._data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection_node),
            "::",
            stringify!(_data)
        )
    );
}
impl Default for _ion_collection_node {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " The collections used by the parser are linked lists which are"]
#[doc = " managed by the collection header."]
#[doc = " the memory used for the nodes is allocated on the parent, which"]
#[doc = " is passed in when the user initializes the collection"]
#[doc = ""]
#[doc = " the nodes in the list have a user sized data buffer, which is"]
#[doc = " expected to a small struct (like ion string) or a scaler (like an"]
#[doc = " int or pointer)."]
#[doc = ""]
#[doc = " the push, pop, and append routines return the address of this"]
#[doc = " data buffer - for push and append it is the buffer of the new node"]
#[doc = " for pop it is the buffer of the released node - which is still"]
#[doc = " allocated and is, therefore, good UNTIL ANOTHER push or append"]
#[doc = " or copy is executed against the containing collection."]
#[doc = ""]
#[doc = " each collections holds a high water mark free list of nodes that"]
#[doc = " were previously used but aren't currently being used"]
#[doc = ""]
#[doc = " to use this as a:"]
#[doc = "    queue you'll want to \"append\" and \"pop head\""]
#[doc = "    stack you'll want to \"push\" and \"pop head\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_collection {
    pub _owner: *mut ::std::os::raw::c_void,
    pub _node_size: i32,
    pub _count: i32,
    pub _head: *mut ION_COLLECTION_NODE,
    pub _tail: *mut ION_COLLECTION_NODE,
    pub _freelist: *mut ION_COLLECTION_NODE,
}
#[test]
fn bindgen_test_layout__ion_collection() {
    assert_eq!(
        ::std::mem::size_of::<_ion_collection>(),
        40usize,
        concat!("Size of: ", stringify!(_ion_collection))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_collection>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_collection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._node_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_node_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._tail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_collection>()))._freelist as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_collection),
            "::",
            stringify!(_freelist)
        )
    );
}
impl Default for _ion_collection {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_symbol_import_location {
    pub name: ION_STRING,
    pub location: SID,
}
#[test]
fn bindgen_test_layout__ion_symbol_import_location() {
    assert_eq!(
        ::std::mem::size_of::<_ion_symbol_import_location>(),
        24usize,
        concat!("Size of: ", stringify!(_ion_symbol_import_location))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_symbol_import_location>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_symbol_import_location))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_symbol_import_location>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol_import_location),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_symbol_import_location>())).location as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol_import_location),
            "::",
            stringify!(location)
        )
    );
}
impl Default for _ion_symbol_import_location {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ION_SYMBOL_IMPORT_LOCATION = _ion_symbol_import_location;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_symbol {
    pub sid: SID,
    pub value: ION_STRING,
    pub import_location: ION_SYMBOL_IMPORT_LOCATION,
    pub add_count: i32,
}
#[test]
fn bindgen_test_layout__ion_symbol() {
    assert_eq!(
        ::std::mem::size_of::<_ion_symbol>(),
        56usize,
        concat!("Size of: ", stringify!(_ion_symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_symbol>())).sid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol),
            "::",
            stringify!(sid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_symbol>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_symbol>())).import_location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol),
            "::",
            stringify!(import_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_symbol>())).add_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_symbol),
            "::",
            stringify!(add_count)
        )
    );
}
impl Default for _ion_symbol {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const _ION_SYMBOL_TABLE_TYPE_ist_EMPTY: _ION_SYMBOL_TABLE_TYPE = 0;
pub const _ION_SYMBOL_TABLE_TYPE_ist_LOCAL: _ION_SYMBOL_TABLE_TYPE = 1;
pub const _ION_SYMBOL_TABLE_TYPE_ist_SHARED: _ION_SYMBOL_TABLE_TYPE = 2;
pub const _ION_SYMBOL_TABLE_TYPE_ist_SYSTEM: _ION_SYMBOL_TABLE_TYPE = 3;
pub type _ION_SYMBOL_TABLE_TYPE = ::std::os::raw::c_uint;
pub use self::_ION_SYMBOL_TABLE_TYPE as ION_SYMBOL_TABLE_TYPE;
extern "C" {
    pub static mut ION_SYMBOL_ION_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_VTM_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_SYMBOL_TABLE_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_NAME_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_VERSION_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_IMPORTS_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_SYMBOLS_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_MAX_ID_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_SHARED_SYMBOL_TABLE_BYTES: [BYTE; 0usize];
}
extern "C" {
    pub static mut ION_SYMBOL_ION_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_VTM_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_SYMBOL_TABLE_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_NAME_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_VERSION_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_IMPORTS_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_SYMBOLS_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_MAX_ID_STRING: ION_STRING;
}
extern "C" {
    pub static mut ION_SYMBOL_SHARED_SYMBOL_TABLE_STRING: ION_STRING;
}
extern "C" {
    pub static mut SYSTEM_SYMBOLS: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " Allocates a new local symbol table."]
    #[doc = " @param p_hsymtab - Pointer to a handle to the newly-allocated symbol table."]
    #[doc = " @param owner - Handle to the new symbol table's memory owner. If NULL, the resulting symbol table is its own memory"]
    #[doc = "  owner and must be freed using `ion_symbol_table_close`."]
    pub fn ion_symbol_table_open(p_hsymtab: *mut hSYMTAB, owner: hOWNER) -> iERR;
}
extern "C" {
    #[doc = " Allocates a new local symbol table of the given type (i.e. shared or local)."]
    #[doc = " @param p_hsymtab - Pointer to a handle to the newly-allocated symbol table."]
    #[doc = " @param owner - Handle to the new symbol table's memory owner. If NULL, the resulting symbol table is its own memory"]
    #[doc = "  owner and must be freed using `ion_symbol_table_close`."]
    pub fn ion_symbol_table_open_with_type(
        p_hsymtab: *mut hSYMTAB,
        owner: hOWNER,
        type_: ION_SYMBOL_TABLE_TYPE,
    ) -> iERR;
}
extern "C" {
    #[doc = " Clones the given symbol table, using that symbol table's memory owner as the owner of the newly allocated symbol"]
    #[doc = " table."]
    #[doc = " @param hsymtab - They symbol table to clone."]
    #[doc = " @param p_hclone - Pointer to a handle to the newly-allocated symbol table clone."]
    pub fn ion_symbol_table_clone(hsymtab: hSYMTAB, p_hclone: *mut hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " Clones the given symbol table, using the given owner as the newly-allocated symbol table's memory owner."]
    #[doc = " @param hsymtab - They symbol table to clone."]
    #[doc = " @param p_hclone - Pointer to a handle to the newly-allocated symbol table clone."]
    #[doc = " @param owner - Handle to the new symbol table's memory owner. If NULL, the resulting symbol table is its own memory"]
    #[doc = "  owner and must be freed using `ion_symbol_table_close`."]
    pub fn ion_symbol_table_clone_with_owner(
        hsymtab: hSYMTAB,
        p_hclone: *mut hSYMTAB,
        owner: hOWNER,
    ) -> iERR;
}
extern "C" {
    #[doc = " Gets the global system symbol table for the given Ion version. This global system symbol table must never be closed."]
    #[doc = " @param p_hsystem_table - Pointer to a handle to the global system symbol table."]
    #[doc = " @param version - The Ion version. Currently, must be 1."]
    pub fn ion_symbol_table_get_system_table(p_hsystem_table: *mut hSYMTAB, version: i32) -> iERR;
}
extern "C" {
    #[doc = " Deserializes a symbol table (shared or local) from the given reader."]
    #[doc = " @param hreader - The reader, positioned at the start of the symbol table struct."]
    #[doc = " @param owner - Handle to the new symbol table's memory owner. If NULL, the resulting symbol table is its own memory"]
    #[doc = "  owner and must be freed using `ion_symbol_table_close`."]
    #[doc = " @param p_hsymtab - Pointer to a handle to the newly-allocated symbol table."]
    pub fn ion_symbol_table_load(hreader: hREADER, owner: hOWNER, p_hsymtab: *mut hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " Serializes a symbol table (shared or local) using the given writer."]
    #[doc = " @param hsymtab - The symbol table to serialize."]
    #[doc = " @param hwriter - The writer (text or binary)."]
    pub fn ion_symbol_table_unload(hsymtab: hSYMTAB, hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_lock(hsymtab: hSYMTAB) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_is_locked(hsymtab: hSYMTAB, p_is_locked: *mut BOOL) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_type(hsymtab: hSYMTAB, p_type: *mut ION_SYMBOL_TABLE_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_name(hsymtab: hSYMTAB, p_name: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_version(hsymtab: hSYMTAB, p_version: *mut i32) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_max_sid(hsymtab: hSYMTAB, p_max_id: *mut SID) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_set_name(hsymtab: hSYMTAB, name: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_set_version(hsymtab: hSYMTAB, version: i32) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_set_max_sid(hsymtab: hSYMTAB, max_id: SID) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_imports(
        hsymtab: hSYMTAB,
        p_imports: *mut *mut ION_COLLECTION,
    ) -> iERR;
}
extern "C" {
    #[doc = " Imports a shared symbol table into a local symbol table, given a description of the import and the catalog in which"]
    #[doc = " it can be found."]
    #[doc = " NOTE: the best match for the described shared symbol table import that is available in the catalog will be used. If"]
    #[doc = " no match is found, all of the import's symbols will be considered to have unknown text."]
    #[doc = " @param hsymtab - The local symbol table into which the imported symbol table will be incorporated."]
    #[doc = " @param pimport - The description of the shared symbol table to be imported."]
    #[doc = " @param catalog - The catalog to query for the matching shared symbol table."]
    pub fn ion_symbol_table_add_import(
        hsymtab: hSYMTAB,
        pimport: *mut ION_SYMBOL_TABLE_IMPORT_DESCRIPTOR,
        catalog: hCATALOG,
    ) -> iERR;
}
extern "C" {
    #[doc = " Imports a shared symbol table into a local symbol table."]
    #[doc = " @param hsymtab - The local symbol table into which the imported symbol table will be incorporated."]
    #[doc = " @param hsymtab_import - The shared symbol table to import."]
    pub fn ion_symbol_table_import_symbol_table(hsymtab: hSYMTAB, hsymtab_import: hSYMTAB) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_find_by_name(hsymtab: hSYMTAB, name: iSTRING, p_sid: *mut SID) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_find_by_sid(hsymtab: hSYMTAB, sid: SID, p_name: *mut iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_is_symbol_known(
        hsymtab: hSYMTAB,
        sid: SID,
        p_is_known: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_symbol(
        hsymtab: hSYMTAB,
        sid: SID,
        p_sym: *mut *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_get_local_symbol(
        hsymtab: hSYMTAB,
        sid: SID,
        p_sym: *mut *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_add_symbol(hsymtab: hSYMTAB, name: iSTRING, p_sid: *mut SID) -> iERR;
}
extern "C" {
    #[doc = " If the given symbol table is its own memory owner, its memory and everything it owns is freed. If the given symbol"]
    #[doc = " table has an external owner and that owner has not been freed, this does nothing; this symbol table will be freed"]
    #[doc = " when its memory owner is freed. If the given symbol table has an external owner which has been freed, the behavior of"]
    #[doc = " this function is undefined."]
    #[doc = " NOTE: Symbol tables constructed and returned by readers and writers are owned by those readers and writers."]
    pub fn ion_symbol_table_close(hsymtab: hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " Copies an ION_SYMBOL to a new memory owner."]
    pub fn ion_symbol_copy_to_owner(
        owner: hOWNER,
        dst: *mut ION_SYMBOL,
        src: *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    #[doc = " Compares the two given ION_SYMBOLs for equality under the Ion data model."]
    pub fn ion_symbol_is_equal(
        lhs: *mut ION_SYMBOL,
        rhs: *mut ION_SYMBOL,
        is_equal: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_symbol_table_type_to_str(t: ION_SYMBOL_TABLE_TYPE) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_stream_user_paged {
    _unused: [u8; 0],
}
pub type ION_STREAM_USER_PAGED = _ion_stream_user_paged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_stream_paged {
    _unused: [u8; 0],
}
pub type ION_STREAM_PAGED = _ion_stream_paged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_page {
    _unused: [u8; 0],
}
pub type ION_PAGE = _ion_page;
pub type PAGE_ID = i32;
pub type POSITION = i64;
extern "C" {
    #[doc = ""]
    pub fn ion_stream_open_buffer(
        buffer: *mut BYTE,
        buf_length: SIZE,
        buf_filled: SIZE,
        read_only: BOOL,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_memory_only(pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_stdin(pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_stdout(pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_stderr(pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_file_in(in_: *mut FILE, pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_file_out(out: *mut FILE, pp_stream: *mut *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_file_rw(
        fp: *mut FILE,
        cache_all: BOOL,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_handler_in(
        fn_input_handler: ION_STREAM_HANDLER,
        handler_state: *mut ::std::os::raw::c_void,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_handler_out(
        fn_output_handler: ION_STREAM_HANDLER,
        handler_state: *mut ::std::os::raw::c_void,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_fd_in(
        fd_in: ::std::os::raw::c_int,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_fd_out(
        fd_out: ::std::os::raw::c_int,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_open_fd_rw(
        fd: ::std::os::raw::c_int,
        cache_all: BOOL,
        pp_stream: *mut *mut ION_STREAM,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_flush(stream: *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_close(stream: *mut ION_STREAM) -> iERR;
}
extern "C" {
    #[doc = ""]
    pub fn ion_stream_can_read(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_can_write(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_can_seek(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_can_mark(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_is_dirty(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_is_mark_open(stream: *mut ION_STREAM) -> BOOL;
}
extern "C" {
    pub fn ion_stream_get_position(stream: *mut ION_STREAM) -> POSITION;
}
extern "C" {
    pub fn ion_stream_get_file_stream(stream: *mut ION_STREAM) -> *mut FILE;
}
extern "C" {
    pub fn ion_stream_get_mark_start(stream: *mut ION_STREAM) -> POSITION;
}
extern "C" {
    pub fn ion_stream_get_marked_length(stream: *mut ION_STREAM) -> POSITION;
}
extern "C" {
    #[doc = ""]
    pub fn ion_stream_read_byte(stream: *mut ION_STREAM, p_c: *mut ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    pub fn ion_stream_read(
        stream: *mut ION_STREAM,
        buf: *mut BYTE,
        len: SIZE,
        p_bytes_read: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_unread_byte(stream: *mut ION_STREAM, c: ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    pub fn ion_stream_write(
        stream: *mut ION_STREAM,
        buf: *mut BYTE,
        len: SIZE,
        p_bytes_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_write_byte(stream: *mut ION_STREAM, byte: ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    pub fn ion_stream_write_byte_no_checks(
        stream: *mut ION_STREAM,
        byte: ::std::os::raw::c_int,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_write_stream(
        stream: *mut ION_STREAM,
        stream_input: *mut ION_STREAM,
        len: SIZE,
        p_written: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_stream_seek(stream: *mut ION_STREAM, position: POSITION) -> iERR;
}
extern "C" {
    pub fn ion_stream_truncate(stream: *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_skip(stream: *mut ION_STREAM, distance: SIZE, p_skipped: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_stream_mark(stream: *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_mark_remark(stream: *mut ION_STREAM, position: POSITION) -> iERR;
}
extern "C" {
    pub fn ion_stream_mark_rewind(stream: *mut ION_STREAM) -> iERR;
}
extern "C" {
    pub fn ion_stream_mark_clear(stream: *mut ION_STREAM) -> iERR;
}
#[doc = " A function that may be called by the reader upon a change to the stream's symbol table context."]
#[doc = ""]
#[doc = " For example, an ION_READER_CONTEXT_CALLBACK function may be used to wrap `ion_writer_add_imported_tables`, with the"]
#[doc = " user context pointing to a writer instance, in order to update the writer's symbol table context in lockstep with"]
#[doc = " the reader."]
#[doc = ""]
#[doc = " @param context - User-provided context, e.g., a hWRITER."]
#[doc = " @param imports - A collection of ION_SYMBOL_TABLE_IMPORT, representing the shared symbol tables in the new symbol"]
#[doc = "  table context."]
pub type ION_READER_CONTEXT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        imports: *mut ION_COLLECTION,
    ) -> iERR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_reader_context_change_notifier {
    #[doc = " The function to call upon a change to the reader's symbol table context."]
    pub notify: ION_READER_CONTEXT_CALLBACK,
    #[doc = " The user context to provide as the first argument to `notify`. May be NULL."]
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ion_reader_context_change_notifier() {
    assert_eq!(
        ::std::mem::size_of::<_ion_reader_context_change_notifier>(),
        16usize,
        concat!("Size of: ", stringify!(_ion_reader_context_change_notifier))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_reader_context_change_notifier>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ion_reader_context_change_notifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_context_change_notifier>())).notify as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_context_change_notifier),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_context_change_notifier>())).context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_context_change_notifier),
            "::",
            stringify!(context)
        )
    );
}
impl Default for _ion_reader_context_change_notifier {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ION_READER_CONTEXT_CHANGE_NOTIFIER = _ion_reader_context_change_notifier;
#[doc = " Reader configuration data, could be supplied by user during reader creation time."]
#[doc = " All fields in the structure are defaulted to 0, except for the following:"]
#[doc = ""]
#[doc = " #define DEFAULT_ANNOTATION_LIMIT         10"]
#[doc = " #define DEFAULT_WRITER_STACK_DEPTH       10"]
#[doc = " #define DEFAULT_CHUNK_THRESHOLD     DEFAULT_BLOCK_SIZE"]
#[doc = " #define DEFAULT_SYMBOL_THRESHOLD        512"]
#[doc = ""]
#[doc = " Some field also has a range limit:"]
#[doc = " #define MIN_ANNOTATION_LIMIT              1"]
#[doc = " #define MIN_WRITER_STACK_DEPTH            2"]
#[doc = " #define MIN_SYMBOL_THRESHOLD             32"]
#[doc = " #define MIN_CHUNK_THRESHOLD              32"]
#[doc = " #define MIN_ION_ALLOCATION_BLOCK_SIZE    32"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_reader_options {
    #[doc = " If true the reader will return otherwise hidden system values"]
    #[doc = ""]
    pub return_system_values: BOOL,
    #[doc = " Character to be treated as new line for line counting, defaults to '\\n'"]
    #[doc = ""]
    pub new_line_char: ::std::os::raw::c_int,
    #[doc = " The max container depth defaults to 10"]
    #[doc = ""]
    pub max_container_depth: SIZE,
    #[doc = " The max number of annotations on 1 value, defaults to 10"]
    #[doc = ""]
    pub max_annotation_count: SIZE,
    #[doc = " The max number number of bytes the annotations on a single value. This"]
    #[doc = "  is an total. How the bytes are divided among the annotations is irrelevant"]
    #[doc = "  (i.e. 1 large, or 100 small may have the same total space requirements)."]
    #[doc = "  defaults to user_value_threshold (or 4096)."]
    #[doc = ""]
    pub max_annotation_buffered: SIZE,
    #[doc = " The size maximum size allowed for symbols, 512 bytes is the default"]
    #[doc = ""]
    pub symbol_threshold: SIZE,
    #[doc = " user value allocation threshold, max size of allocation made to process"]
    #[doc = "  any value returned to the user, default is 4096. Includes symbol, int,"]
    #[doc = "  decimal, timestamp, blob values in all cases. This includes string, clob,"]
    #[doc = "  and blob values if they are to be returned to the caller in a contiguous"]
    #[doc = "  buffer."]
    #[doc = ""]
    pub user_value_threshold: SIZE,
    #[doc = " The size over which long values are returned as chunks. This is only"]
    #[doc = "  valid for string, clob and blob values as all others must be buffered"]
    #[doc = "  up to the limit of user_value_threshold. The default is 4096."]
    #[doc = ""]
    pub chunk_threshold: SIZE,
    #[doc = " Memory is allocated in pages owned by the primary entities it's default size is 4096"]
    #[doc = ""]
    pub allocation_page_size: SIZE,
    #[doc = " If true this will disable validation of string content which verifies the"]
    #[doc = "  string returned is in fact a valid UTF-8 sequence.  This defaults to false."]
    pub skip_character_validation: BOOL,
    #[doc = " Handle to catalog of shared symbol tables for the reader to use. If NULL, will be treated as empty."]
    #[doc = ""]
    pub pcatalog: *mut ION_CATALOG,
    #[doc = " Handle to the decNumber context for the reader to use. This allows configuration of the maximum number of"]
    #[doc = " decimal digits, decimal exponent range, etc. See decContextDefault in decContext.h for simple initialization."]
    #[doc = ""]
    #[doc = " If NULL, the reader will initialize its decimal context by calling decContextDefault with the DEC_INIT_DECQUAD"]
    #[doc = " option, which results in a maximum of 34 decimal digits and an exponent range of [-6143, 6144]."]
    #[doc = ""]
    #[doc = " Note that up to 34 digits of precision will always be supported, even if configured to be less than 34."]
    pub decimal_context: *mut decContext,
    #[doc = " Notification callback data to be used upon symbol table context change. Ignored if"]
    #[doc = " `context_change_notifier.notify` is NULL."]
    pub context_change_notifier: ION_READER_CONTEXT_CHANGE_NOTIFIER,
}
#[test]
fn bindgen_test_layout__ion_reader_options() {
    assert_eq!(
        ::std::mem::size_of::<_ion_reader_options>(),
        72usize,
        concat!("Size of: ", stringify!(_ion_reader_options))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_reader_options>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_reader_options))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).return_system_values as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(return_system_values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).new_line_char as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(new_line_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).max_container_depth as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(max_container_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).max_annotation_count as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(max_annotation_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).max_annotation_buffered as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(max_annotation_buffered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).symbol_threshold as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(symbol_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).user_value_threshold as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(user_value_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).chunk_threshold as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(chunk_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).allocation_page_size as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(allocation_page_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).skip_character_validation as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(skip_character_validation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_reader_options>())).pcatalog as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(pcatalog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).decimal_context as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(decimal_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_reader_options>())).context_change_notifier as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_reader_options),
            "::",
            stringify!(context_change_notifier)
        )
    );
}
impl Default for _ion_reader_options {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Reader configuration data, could be supplied by user during reader creation time."]
#[doc = " All fields in the structure are defaulted to 0, except for the following:"]
#[doc = ""]
#[doc = " #define DEFAULT_ANNOTATION_LIMIT         10"]
#[doc = " #define DEFAULT_WRITER_STACK_DEPTH       10"]
#[doc = " #define DEFAULT_CHUNK_THRESHOLD     DEFAULT_BLOCK_SIZE"]
#[doc = " #define DEFAULT_SYMBOL_THRESHOLD        512"]
#[doc = ""]
#[doc = " Some field also has a range limit:"]
#[doc = " #define MIN_ANNOTATION_LIMIT              1"]
#[doc = " #define MIN_WRITER_STACK_DEPTH            2"]
#[doc = " #define MIN_SYMBOL_THRESHOLD             32"]
#[doc = " #define MIN_CHUNK_THRESHOLD              32"]
#[doc = " #define MIN_ION_ALLOCATION_BLOCK_SIZE    32"]
#[doc = ""]
pub type ION_READER_OPTIONS = _ion_reader_options;
extern "C" {
    #[doc = " Allocates a new reader consuming a given buffer of data."]
    #[doc = ""]
    #[doc = " @param p_hreader will receive a pointer to the new reader."]
    #[doc = "   It must be freed via ion_reader_close()."]
    #[doc = " @param buffer the Ion data to read, either UTF-8 text or binary."]
    #[doc = "   Must be a valid handle. The caller retains ownership of the buffer and"]
    #[doc = "   must ensure that its data is unmodified until the reader is closed."]
    #[doc = " @param buf_length the length of the buffer"]
    #[doc = " @param p_options may be null, in that case, default value will be used."]
    pub fn ion_reader_open_buffer(
        p_hreader: *mut hREADER,
        buffer: *mut BYTE,
        buf_length: SIZE,
        p_options: *mut ION_READER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    #[doc = " Create hREADER object, and associate it with the stream for reading."]
    #[doc = ""]
    #[doc = " The hREADER object itself does not have a read data buffer, it's using the buffer from handler_state, which"]
    #[doc = " usually contains a BYTE[]."]
    #[doc = ""]
    #[doc = " hREADER object will invoke fn_input_handler to read from input data source (File, for example) and fill"]
    #[doc = " the BYTE[] in handler_state."]
    #[doc = ""]
    #[doc = "<pre>"]
    #[doc = "typedef struct _test_file {"]
    #[doc = "FILE *in;"]
    #[doc = "int   block_size;"]
    #[doc = "BYTE *buffer;"]
    #[doc = "} TEST_FILE;"]
    #[doc = "BYTE      g_buffer[1024];"]
    #[doc = "TEST_FILE g_test_file ="]
    #[doc = "{"]
    #[doc = "NULL,"]
    #[doc = "TEST_FILE_BUF_MAX,"]
    #[doc = "g_buffer"]
    #[doc = "};"]
    #[doc = "iERR test_stream_handler(struct _ion_stream *pstream)"]
    #[doc = "{"]
    #[doc = "iENTER;"]
    #[doc = "TEST_FILE *tfile;"]
    #[doc = "SIZE len;"]
    #[doc = "tfile = (TEST_FILE *)pstream->handler_state;"]
    #[doc = "pstream->curr = tfile->buffer;"]
    #[doc = "len = fread( tfile->buffer, sizeof(*tfile->buffer), tfile->block_size, g_test_file.in );"]
    #[doc = "if (len < 1) {"]
    #[doc = "pstream->limit = NULL;"]
    #[doc = "DONTFAILWITH(IERR_EOF);"]
    #[doc = "}"]
    #[doc = "pstream->limit = pstream->curr + len;"]
    #[doc = "iRETURN;"]
    #[doc = "}"]
    #[doc = "fstream = fopen(pathname, \"r\");"]
    #[doc = "g_test_file.in = fstream;"]
    #[doc = "ion_reader_open_stream(&reader, &g_test_file, test_stream_handler, NULL);"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " @param   p_hreader           Newly created reader object will be stored here."]
    #[doc = " @param   p_stream            stream opened with ion_stream functions"]
    #[doc = " @param   p_options const,    Reader configuration data object, used while creating reader object."]
    #[doc = " @return  IERR_OK if succeeded"]
    pub fn ion_reader_open_stream(
        p_hreader: *mut hREADER,
        handler_state: *mut ::std::os::raw::c_void,
        fn_input_handler: ION_STREAM_HANDLER,
        p_options: *mut ION_READER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    #[doc = " Resets input stream for given reader."]
    #[doc = ""]
    #[doc = " readers' current stream would be closed and would be initialized with given stream."]
    #[doc = " catalog, symbol table, dec_context & other reader defaults would be reused [ @see _ion_reader_initialize impl.]"]
    #[doc = ""]
    #[doc = " @param   p_hreader   Reader object for which input stream is to be reset"]
    #[doc = " @param   handler_state   Object that contains a buffer to store the read-in data from input stream."]
    #[doc = " @param   fn_input_handler    Function used to read from input stream and refill the buffer."]
    #[doc = "                              the handler is responsible for settting start, curr and limit of reader object"]
    #[doc = "                              it may opt to change the handler_state if it wants to."]
    #[doc = "                              on this first call it is actually handling whatever initialization"]
    #[doc = "                              it might need as well"]
    #[doc = " @return  IERR_OK if succeeded"]
    pub fn ion_reader_reset_stream(
        p_hreader: *mut hREADER,
        handler_state: *mut ::std::os::raw::c_void,
        fn_input_handler: ION_STREAM_HANDLER,
    ) -> iERR;
}
extern "C" {
    #[doc = " Resets input user-managed stream for given reader."]
    #[doc = ""]
    #[doc = " Readers' current stream would be closed and would be initialized with given stream."]
    #[doc = " Resets the state of the reader to be at the top level. Symbol table and other reader state such as"]
    #[doc = " whether its a binary or a text reader is retained."]
    #[doc = " A common pattern when using this interface would be to open the reader with a user-managed-stream,"]
    #[doc = " Then call ion_reader_next which will read the"]
    #[doc = " ion version marker and the initial local symbol table (if one"]
    #[doc = " is present).  At that point the symbol table will be current."]
    #[doc = " A later user-managed-stream seek is immediately followed by calling this API."]
    #[doc = " This ensures symbol table is retained and reader/parser state is valid following the random jump;"]
    #[doc = " and parsing continues unhindered from thereon."]
    #[doc = " @param   p_hreader            Reader object for which input stream is to be reset"]
    #[doc = " @param   handler_state        Object that contains a buffer to store the read-in data from input stream."]
    #[doc = " @param   fn_input_handler     Function used to read from input stream and refill the buffer."]
    #[doc = "                               the handler is responsible for setting start, curr and limit of reader"]
    #[doc = "                               object."]
    #[doc = " @param   length               Length of the user-managed-stream. An EOF by the reader when this length"]
    #[doc = "                               is reached."]
    #[doc = " @return  IERR_OK if succeeded"]
    pub fn ion_reader_reset_stream_with_length(
        p_hreader: *mut hREADER,
        handler_state: *mut ::std::os::raw::c_void,
        fn_input_handler: ION_STREAM_HANDLER,
        length: POSITION,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_open(
        p_hreader: *mut hREADER,
        p_stream: *mut ION_STREAM,
        p_options: *mut ION_READER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_catalog(hreader: hREADER, p_hcatalog: *mut hCATALOG) -> iERR;
}
extern "C" {
    #[doc = " moves the stream position to the specified offset. Resets the"]
    #[doc = "  the state of the reader to be at the top level. As long as the"]
    #[doc = "  specified position is at the first byte of a top-level value"]
    #[doc = "  (just before the type description byte) this will work neatly."]
    #[doc = "  Do not attempt to seek to a value below the top level, as the"]
    #[doc = "  view of the data is likely to be invalid."]
    #[doc = ""]
    #[doc = "  If a length is specified (default is -1 or no limit) eof will"]
    #[doc = "  be returned when length bytes are consumed."]
    #[doc = ""]
    #[doc = "  A common pattern when using this interface would be to open"]
    #[doc = "  the reader from an in memory buffer stream or a seek-able"]
    #[doc = "  file handle.  Then call ion_reader_next which will read the"]
    #[doc = "  ion version marker and the initial local symbol table (if one"]
    #[doc = "  is present).  At that point the symbol table will be current"]
    #[doc = "  and later seek's will have an appropriate symbol table to use."]
    pub fn ion_reader_seek(hreader: hREADER, offset: POSITION, length: SIZE) -> iERR;
}
extern "C" {
    #[doc = " set the current symbol table to the table passed in.  This"]
    #[doc = "  can be used to reset the readers symbol"]
    #[doc = "  table is you wish to seek in a stream which contains multiple"]
    #[doc = "  symbol tables.  This symbol table handle should be a handle"]
    #[doc = "  returned by ion_reader_get_symbol_table."]
    pub fn ion_reader_set_symbol_table(hreader: hREADER, hsymtab: hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " returns the offset of the value the reader is currently"]
    #[doc = "  positioned on.  This offset is appropriate to use later"]
    #[doc = "  to seek to."]
    pub fn ion_reader_get_value_offset(hreader: hREADER, p_offset: *mut POSITION) -> iERR;
}
extern "C" {
    #[doc = " returns the length of the value the reader is currently"]
    #[doc = "  positioned on.  This length is appropriate to use later"]
    #[doc = "  when calling ion_reader_seek to limit \"over-reading\" in"]
    #[doc = "  the underlying stream which could result in errors that"]
    #[doc = "  are not really of interest. NOTE: readers of text data"]
    #[doc = "  will always set *p_length to -1 because text Ion data is"]
    #[doc = "  not length-prefixed. When the reader may be reading text"]
    #[doc = "  Ion data, the correct way to calculate a value's length"]
    #[doc = "  is by subtracting the current value's offset (see"]
    #[doc = "  `ion_reader_get_value_offset`) from the next value's"]
    #[doc = "  offset. This technique will work for both binary and text"]
    #[doc = "  Ion data."]
    pub fn ion_reader_get_value_length(hreader: hREADER, p_length: *mut SIZE) -> iERR;
}
extern "C" {
    #[doc = " returns the current symbol table the value the reader is currently"]
    #[doc = "  positioned on.  This can be used to reset the readers symbol"]
    #[doc = "  table is you wish to seek in a stream which contains multiple"]
    #[doc = "  symbol tables.  This symbol table handle can be used to call"]
    #[doc = "  ion_reader_set_symbol_table."]
    pub fn ion_reader_get_symbol_table(hreader: hREADER, p_hsymtab: *mut hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " Returns the next ION_TYPE in the stream. In case of EOF, IERR_OK will be returned. p_value_type = tid_EOF."]
    #[doc = " @param   hreader"]
    #[doc = " @param   p_value_type    ION_TYPE (tid_EOF, tid_BOOL, etc, defined in ion_const.h). tid_EOF if EOF."]
    pub fn ion_reader_next(hreader: hREADER, p_value_type: *mut ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_reader_step_in(hreader: hREADER) -> iERR;
}
extern "C" {
    pub fn ion_reader_step_out(hreader: hREADER) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_depth(hreader: hREADER, p_depth: *mut SIZE) -> iERR;
}
extern "C" {
    #[doc = " Returns the type of the current value, or tid_none if no value has been assigned. (before next() is called)"]
    pub fn ion_reader_get_type(hreader: hREADER, p_value_type: *mut ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_reader_has_any_annotations(
        hreader: hREADER,
        p_has_any_annotations: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_has_annotation(
        hreader: hREADER,
        annotation: iSTRING,
        p_annotation_found: *mut BOOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_is_null(hreader: hREADER, p_is_null: *mut BOOL) -> iERR;
}
extern "C" {
    pub fn ion_reader_is_in_struct(preader: hREADER, p_is_in_struct: *mut BOOL) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_field_name(hreader: hREADER, p_str: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_field_name_symbol(
        hreader: hREADER,
        p_psymbol: *mut *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_annotations(
        hreader: hREADER,
        p_strs: iSTRING,
        max_count: SIZE,
        p_count: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_annotation_symbols(
        hreader: hREADER,
        p_symbols: *mut ION_SYMBOL,
        max_count: SIZE,
        p_count: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_annotation_count(hreader: hREADER, p_count: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_an_annotation(
        hreader: hREADER,
        idx: ::std::os::raw::c_int,
        p_strs: iSTRING,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_an_annotation_symbol(
        hreader: hREADER,
        idx: ::std::os::raw::c_int,
        p_symbol: *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_null(hreader: hREADER, p_value: *mut ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_bool(hreader: hREADER, p_value: *mut BOOL) -> iERR;
}
extern "C" {
    #[doc = " Read integer value from Ion stream."]
    #[doc = " The size of the integer is sizeof(int)"]
    #[doc = " If the value in the Ion stream does not fit into the variable, it will return with IERR_NUMERIC_OVERFLOW."]
    pub fn ion_reader_read_int(hreader: hREADER, p_value: *mut ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    #[doc = " Read integer value from Ion stream."]
    #[doc = " The size of the integer is sizeof(int32_t)"]
    #[doc = " If the value in the Ion stream does not fit into the variable, it will return with IERR_NUMERIC_OVERFLOW."]
    pub fn ion_reader_read_int32(hreader: hREADER, p_value: *mut i32) -> iERR;
}
extern "C" {
    #[doc = " Read integer value from Ion stream."]
    #[doc = " The size of the integer is sizeof(int64_t)"]
    #[doc = " If the value in the Ion stream does not fit into the variable, it will return with IERR_NUMERIC_OVERFLOW."]
    pub fn ion_reader_read_int64(hreader: hREADER, p_value: *mut i64) -> iERR;
}
extern "C" {
    #[doc = " Read integer value from Ion stream."]
    #[doc = " This supports arbitary length integers defined by ion_int."]
    pub fn ion_reader_read_ion_int(hreader: hREADER, p_value: *mut ION_INT) -> iERR;
}
extern "C" {
    #[doc = " Read integer value from Ion stream."]
    #[doc = " The size of the integer is sizeof(long), which is 4 or 8 bytes depends on the OS"]
    #[doc = " If the value in the Ion stream does not fit into the variable, it will return with IERR_NUMERIC_OVERFLOW."]
    pub fn ion_reader_read_long(hreader: hREADER, p_value: *mut ::std::os::raw::c_long) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_double(hreader: hREADER, p_value: *mut f64) -> iERR;
}
extern "C" {
    #[doc = " @deprecated use of decQuads directly is deprecated. ION_DECIMAL should be used. See `ion_reader_read_ion_decimal`."]
    pub fn ion_reader_read_decimal(hreader: hREADER, p_value: *mut decQuad) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_ion_decimal(hreader: hREADER, p_value: *mut ION_DECIMAL) -> iERR;
}
extern "C" {
    #[doc = " @return IERR_NULL_VALUE if the current value is null.timestamp."]
    pub fn ion_reader_read_timestamp(hreader: hREADER, p_value: iTIMESTAMP) -> iERR;
}
extern "C" {
    #[doc = " Read the current symbol value as an ION_SYMBOL."]
    pub fn ion_reader_read_ion_symbol(hreader: hREADER, p_symbol: *mut ION_SYMBOL) -> iERR;
}
extern "C" {
    #[doc = " Determines the content of the current text value, which must be an"]
    #[doc = " Ion string or symbol.  The reader retains ownership of the returned byte"]
    #[doc = " array, and the caller must copy the data out (if necessary) before moving"]
    #[doc = " the cursor."]
    #[doc = ""]
    #[doc = " @param hreader must be a valid handle."]
    #[doc = ""]
    #[doc = " @param p_value receives the string information."]
    pub fn ion_reader_get_string_length(hreader: hREADER, p_length: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_string(hreader: hREADER, p_value: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_partial_string(
        hreader: hREADER,
        p_buf: *mut BYTE,
        buf_max: SIZE,
        p_length: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_lob_size(hreader: hREADER, p_length: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_lob_bytes(
        hreader: hREADER,
        p_buf: *mut BYTE,
        buf_max: SIZE,
        p_length: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_read_lob_partial_bytes(
        hreader: hREADER,
        p_buf: *mut BYTE,
        buf_max: SIZE,
        p_length: *mut SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_reader_get_position(
        hreader: hREADER,
        p_bytes: *mut i64,
        p_line: *mut i32,
        p_offset: *mut i32,
    ) -> iERR;
}
extern "C" {
    #[doc = " Closes a reader and releases associated memory.  The caller is responsible"]
    #[doc = " for releasing the underlying buffer (if any).  After calling this method"]
    #[doc = " the given handle will no longer be value."]
    #[doc = ""]
    #[doc = " @param hreader must be a valid handle."]
    pub fn ion_reader_close(hreader: hREADER) -> iERR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ion_writer_options {
    pub output_as_binary: BOOL,
    #[doc = " On text output, this escapes non-ascii characters. So the output file is pure ascii, only valid for text output"]
    #[doc = ""]
    pub escape_all_non_ascii: BOOL,
    #[doc = " Turns on pretty printing, only valid for text output"]
    #[doc = ""]
    pub pretty_print: BOOL,
    #[doc = " Uses tabs for indenting instead of spaces"]
    #[doc = ""]
    pub indent_with_tabs: BOOL,
    #[doc = " Sets indent amount for pretty printing. Defaults to 2. Ignored if indent_with_tabs is true."]
    #[doc = ""]
    pub indent_size: SIZE,
    #[doc = " Puts \"small\" containers on a single line instead of putting all values on separate lines"]
    #[doc = ""]
    pub small_containers_in_line: BOOL,
    #[doc = " Turns off the otherwise automatic insertion of system values (like symbol tables)"]
    #[doc = ""]
    pub supress_system_values: BOOL,
    #[doc = " Turns on very active flushing of the internal streams (text only)"]
    #[doc = ""]
    pub flush_every_value: BOOL,
    #[doc = " The max container depth defaults to 10"]
    #[doc = ""]
    pub max_container_depth: SIZE,
    #[doc = " The max number of annotations on 1 value, defaults to 10"]
    #[doc = ""]
    pub max_annotation_count: SIZE,
    #[doc = " The temp buffer is used to hold temp strings (etc) default is 1024"]
    #[doc = ""]
    pub temp_buffer_size: SIZE,
    #[doc = " memory is allocated in pages owned by the primary entities it's default size is 4096"]
    #[doc = ""]
    pub allocation_page_size: SIZE,
    #[doc = " Handle to catalog of shared symbol tables for the writer to use"]
    #[doc = ""]
    pub pcatalog: *mut ION_CATALOG,
    #[doc = " An ordered list of ION_SYMBOL_TABLE_IMPORT that the writer will import into each new local"]
    #[doc = "  symbol table context. Should be initialized by calling `ion_writer_options_initialize_shared_imports`,"]
    #[doc = "  populated by calling `ion_writer_options_add_shared_imports` and/or"]
    #[doc = "  `ion_writer_options_add_shared_imports_symbol_tables`, and freed by calling"]
    #[doc = "  `ion_writer_options_close_shared_imports`."]
    #[doc = ""]
    #[doc = "  NOTE: the system symbol table is always used as the first import; it need not be provided here."]
    pub encoding_psymbol_table: ION_COLLECTION,
    #[doc = " Handle to the decNumber context for the writer to use. This allows configuration of the maximum number of"]
    #[doc = " decimal digits, decimal exponent range, etc. See decContextDefault in decContext.h for simple initialization."]
    #[doc = ""]
    #[doc = " If NULL, the writer will initialize its decimal context by calling decContextDefault with the DEC_INIT_DECQUAD"]
    #[doc = " option, which results in a maximum of 34 decimal digits and an exponent range of [-6143, 6144]."]
    #[doc = ""]
    #[doc = " Note that up to 34 digits of precision will always be supported, even if configured to be less than 34."]
    pub decimal_context: *mut decContext,
    #[doc = " Normally floating point numbers (`float` or `double`) are written as 32-bit or 64-bit Ion floats depending"]
    #[doc = "  on which Ion writer API is used. When enabled, this API allows the writer to represent a 64-bit float"]
    #[doc = "  with only 32 bits whenever possible without losing precision."]
    #[doc = ""]
    pub compact_floats: BOOL,
}
#[test]
fn bindgen_test_layout__ion_writer_options() {
    assert_eq!(
        ::std::mem::size_of::<_ion_writer_options>(),
        112usize,
        concat!("Size of: ", stringify!(_ion_writer_options))
    );
    assert_eq!(
        ::std::mem::align_of::<_ion_writer_options>(),
        8usize,
        concat!("Alignment of ", stringify!(_ion_writer_options))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).output_as_binary as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(output_as_binary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).escape_all_non_ascii as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(escape_all_non_ascii)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).pretty_print as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(pretty_print)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).indent_with_tabs as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(indent_with_tabs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_writer_options>())).indent_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(indent_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).small_containers_in_line as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(small_containers_in_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).supress_system_values as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(supress_system_values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).flush_every_value as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(flush_every_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).max_container_depth as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(max_container_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).max_annotation_count as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(max_annotation_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).temp_buffer_size as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(temp_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).allocation_page_size as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(allocation_page_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ion_writer_options>())).pcatalog as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(pcatalog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).encoding_psymbol_table as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(encoding_psymbol_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).decimal_context as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(decimal_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ion_writer_options>())).compact_floats as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ion_writer_options),
            "::",
            stringify!(compact_floats)
        )
    );
}
impl Default for _ion_writer_options {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type ION_WRITER_OPTIONS = _ion_writer_options;
extern "C" {
    #[doc = " Initializes the options' imports list. This must be done before calling `ion_writer_options_add_*`."]
    #[doc = " NOTE: This does NOT need to be called if the writer does not need to use shared imports."]
    #[doc = " @param options - The writer options containing the imports list to initialize."]
    pub fn ion_writer_options_initialize_shared_imports(options: *mut ION_WRITER_OPTIONS) -> iERR;
}
extern "C" {
    #[doc = " Adds the imports from the given collection of ION_SYMBOL_TABLE_IMPORT to the options' imports list."]
    #[doc = " `ion_writer_options_initialize_shared_imports` must have been called first. The given collection must not contain"]
    #[doc = " a system symbol table."]
    pub fn ion_writer_options_add_shared_imports(
        options: *mut ION_WRITER_OPTIONS,
        imports: *mut ION_COLLECTION,
    ) -> iERR;
}
extern "C" {
    #[doc = " Adds the given array of ION_SYMBOL_TABLE (which must be shared symbol tables) to the options' imports list."]
    #[doc = " `ion_writer_options_initialize_shared_imports` must have been called first. The given array must not contain"]
    #[doc = " a system symbol table."]
    pub fn ion_writer_options_add_shared_imports_symbol_tables(
        options: *mut ION_WRITER_OPTIONS,
        imports: *mut *mut ION_SYMBOL_TABLE,
        imports_count: SIZE,
    ) -> iERR;
}
extern "C" {
    #[doc = " Frees the options' imports list. This must be done once the options are no longer needed, and only if"]
    #[doc = " `ion_writer_options_initialize_shared_imports` was called."]
    pub fn ion_writer_options_close_shared_imports(options: *mut ION_WRITER_OPTIONS) -> iERR;
}
extern "C" {
    #[doc = " Ion Writer interfaces. Takes a byte buffer and length which"]
    #[doc = "  will contain the text or binary content, returns handle to a writer."]
    #[doc = "  @param  p_hwriter"]
    #[doc = "  @param  buffer  Byte buffer, allocated and provided by caller."]
    #[doc = "  @param  buf_length  size of the buffer (0 or greater). If the buffer is not big enough, ion_write"]
    #[doc = "                      operation will return IERR_EOF rather than IERR_OK."]
    #[doc = "  @param  p_option    writer configuration object."]
    pub fn ion_writer_open_buffer(
        p_hwriter: *mut hWRITER,
        buffer: *mut BYTE,
        buf_length: SIZE,
        p_options: *mut ION_WRITER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    #[doc = " Open stream to write ion data."]
    #[doc = " @param   p_hwriter"]
    #[doc = " @param   fn_block_handler    User provided function to write from handler_state buffer to file,"]
    #[doc = " @param   handler_state       Related to write buffer. ion_writer will write to the buffer provided by the handler_state,"]
    #[doc = "                              fn_block_handler will write the buffer to file."]
    #[doc = " @param   p_options           writer configuration object."]
    #[doc = " @see ion_reader_open_stream"]
    #[doc = " @see ion_writer_open_buffer"]
    pub fn ion_writer_open_stream(
        p_hwriter: *mut hWRITER,
        fn_output_handler: ION_STREAM_HANDLER,
        handler_state: *mut ::std::os::raw::c_void,
        p_options: *mut ION_WRITER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    pub fn ion_writer_open(
        p_hwriter: *mut hWRITER,
        p_stream: *mut ION_STREAM,
        p_options: *mut ION_WRITER_OPTIONS,
    ) -> iERR;
}
extern "C" {
    pub fn ion_writer_get_depth(hwriter: hWRITER, p_depth: *mut SIZE) -> iERR;
}
extern "C" {
    pub fn ion_writer_set_catalog(hwriter: hWRITER, hcatalog: hCATALOG) -> iERR;
}
extern "C" {
    pub fn ion_writer_get_catalog(hwriter: hWRITER, p_hcatalog: *mut hCATALOG) -> iERR;
}
extern "C" {
    #[doc = " Sets the writer's symbol table."]
    #[doc = ""]
    #[doc = " If the writer's current symbol table context must be serialized, forces the writer to finish and flush its current"]
    #[doc = " symbol table context (with the same side-effects as `ion_writer_finish`) first. If the given symbol table is a shared"]
    #[doc = " symbol table, a new local symbol table that imports that shared symbol table is created. Raises an error if a"]
    #[doc = " manually-written symbol table is in progress or if the writer is not at the top level."]
    pub fn ion_writer_set_symbol_table(hwriter: hWRITER, hsymtab: hSYMTAB) -> iERR;
}
extern "C" {
    pub fn ion_writer_get_symbol_table(hwriter: hWRITER, p_hsymtab: *mut hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " Adds the given list of imports to the writer's list of imports. These imports will only be used in the writer's"]
    #[doc = " current symbol table context. To configure the writer to use the same list of imports for each new symbol table"]
    #[doc = " context, convey that list of imports through ION_WRITER_OPTIONS."]
    #[doc = ""]
    #[doc = " If the writer's current symbol table context must be serialized, forces the writer to finish and flush its current"]
    #[doc = " symbol table context (with the same side-effects as `ion_writer_finish`) first. A new symbol table context is then"]
    #[doc = " created, starting with any imports specified in ION_WRITER_OPTIONS, and followed by the list of imports given to this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " This function may be called multiple times in succession without changing the current symbol table context as long as"]
    #[doc = " no values have been written in between calls; in this case, this function appends to the writer's list of imports."]
    #[doc = ""]
    #[doc = " Raises an error if a manually-written symbol table is in progress, if the writer is not at the top level, or if the"]
    #[doc = " writer has pending annotations."]
    pub fn ion_writer_add_imported_tables(hwriter: hWRITER, imports: *mut ION_COLLECTION) -> iERR;
}
extern "C" {
    #[doc = " Sets the writer's current field name. Only valid if the writer is currently in a struct. It is the caller's"]
    #[doc = " responsibility to keep `name` in scope until the writer's next value is written."]
    pub fn ion_writer_write_field_name(hwriter: hWRITER, name: iSTRING) -> iERR;
}
extern "C" {
    #[doc = " Sets the writer's current field name from the given Ion symbol. Only valid if the writer is currently in a struct."]
    #[doc = " It is the caller's responsibility to keep `field_name` in scope until the writer's next value is written."]
    pub fn ion_writer_write_field_name_symbol(
        hwriter: hWRITER,
        field_name: *mut ION_SYMBOL,
    ) -> iERR;
}
extern "C" {
    pub fn ion_writer_clear_field_name(hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_writer_add_annotation(hwriter: hWRITER, annotation: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_writer_add_annotation_symbol(hwriter: hWRITER, annotation: *mut ION_SYMBOL) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_annotations(
        hwriter: hWRITER,
        p_annotations: iSTRING,
        count: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_annotation_symbols(
        hwriter: hWRITER,
        annotations: *mut ION_SYMBOL,
        count: SIZE,
    ) -> iERR;
}
extern "C" {
    pub fn ion_writer_clear_annotations(hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_null(hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_typed_null(hwriter: hWRITER, type_: ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_bool(hwriter: hWRITER, value: BOOL) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_int(hwriter: hWRITER, value: ::std::os::raw::c_int) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_int32(hwriter: hWRITER, value: i32) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_int64(hwriter: hWRITER, value: i64) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_long(hwriter: hWRITER, value: ::std::os::raw::c_long) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_ion_int(hwriter: hWRITER, value: *mut ION_INT) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_double(hwriter: hWRITER, value: f64) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_float(hwriter: hWRITER, value: f32) -> iERR;
}
extern "C" {
    #[doc = " @deprecated use of decQuads directly is deprecated. ION_DECIMAL should be used. See `ion_writer_write_ion_decimal`."]
    pub fn ion_writer_write_decimal(hwriter: hWRITER, value: *mut decQuad) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_ion_decimal(hwriter: hWRITER, value: *mut ION_DECIMAL) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_timestamp(hwriter: hWRITER, value: iTIMESTAMP) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_symbol(hwriter: hWRITER, p_value: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_ion_symbol(hwriter: hWRITER, symbol: *mut ION_SYMBOL) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_string(hwriter: hWRITER, p_value: iSTRING) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_clob(hwriter: hWRITER, p_buf: *mut BYTE, length: SIZE) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_blob(hwriter: hWRITER, p_buf: *mut BYTE, length: SIZE) -> iERR;
}
extern "C" {
    pub fn ion_writer_start_lob(hwriter: hWRITER, lob_type: ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_writer_append_lob(hwriter: hWRITER, p_buf: *mut BYTE, length: SIZE) -> iERR;
}
extern "C" {
    pub fn ion_writer_finish_lob(hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_writer_start_container(hwriter: hWRITER, container_type: ION_TYPE) -> iERR;
}
extern "C" {
    pub fn ion_writer_finish_container(hwriter: hWRITER) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_one_value(hwriter: hWRITER, hreader: hREADER) -> iERR;
}
extern "C" {
    pub fn ion_writer_write_all_values(hwriter: hWRITER, hreader: hREADER) -> iERR;
}
extern "C" {
    #[doc = " Flushes pending bytes without forcing an Ion Version Marker or ending the current symbol table context."]
    #[doc = " If writer was created using open_stream, also flushes write buffer to stream. If any value is in-progress, flushing"]
    #[doc = " any writer is an error."]
    #[doc = " @param   p_bytes_flushed - the number of bytes written into the buffer/stream."]
    pub fn ion_writer_flush(hwriter: hWRITER, p_bytes_flushed: *mut SIZE) -> iERR;
}
extern "C" {
    #[doc = " Flushes pending bytes, ending the current symbol table context and forcing an Ion Version Marker if the writer"]
    #[doc = " continues writing to the stream. If writer was created using open_stream, also flushes write buffer to stream."]
    #[doc = " If any value is in-progress, finishing any writer is an error."]
    #[doc = " @param   p_bytes_flushed - the number of bytes written into the buffer/stream."]
    pub fn ion_writer_finish(hwriter: hWRITER, p_bytes_flushed: *mut SIZE) -> iERR;
}
extern "C" {
    #[doc = " Finishes the writer, frees the writer's associated resources, and finally frees the writer itself. The writer may"]
    #[doc = " not continue writing to the stream after this function is called. If any value is in-progress, closing any writer"]
    #[doc = " raises an error, but still frees the writer and any associated memory."]
    pub fn ion_writer_close(hwriter: hWRITER) -> iERR;
}
extern "C" {
    #[doc = " Allocates a new catalog with itself as its memory owner. Must be freed using `ion_catalog_close`."]
    #[doc = " @param p_hcatalog - Pointer to a handle to the newly-allocated catalog."]
    pub fn ion_catalog_open(p_hcatalog: *mut hCATALOG) -> iERR;
}
extern "C" {
    #[doc = " Allocates a new catalog with the given owner as its memory owner."]
    #[doc = " @param p_hcatalog - Pointer to a handle to the newly-allocated catalog."]
    #[doc = " @param owner - Handle to the new catalog's memory owner. If NULL, the resulting catalog is its own memory owner and"]
    #[doc = "  must be freed using `ion_catalog_close`."]
    pub fn ion_catalog_open_with_owner(p_hcatalog: *mut hCATALOG, owner: hOWNER) -> iERR;
}
extern "C" {
    pub fn ion_catalog_get_symbol_table_count(hcatalog: hCATALOG, p_count: *mut i32) -> iERR;
}
extern "C" {
    pub fn ion_catalog_add_symbol_table(hcatalog: hCATALOG, symtab: hSYMTAB) -> iERR;
}
extern "C" {
    pub fn ion_catalog_find_symbol_table(
        hcatalog: hCATALOG,
        name: iSTRING,
        version: ::std::os::raw::c_long,
        p_symtab: *mut hSYMTAB,
    ) -> iERR;
}
extern "C" {
    pub fn ion_catalog_find_best_match(
        hcatalog: hCATALOG,
        name: iSTRING,
        version: ::std::os::raw::c_long,
        p_symtab: *mut hSYMTAB,
    ) -> iERR;
}
extern "C" {
    pub fn ion_catalog_release_symbol_table(hcatalog: hCATALOG, symtab: hSYMTAB) -> iERR;
}
extern "C" {
    #[doc = " If the given catalog is its own memory owner, its memory and everything it owns is freed. If the given catalog has an"]
    #[doc = " external owner and that owner has not been freed, this does nothing; this catalog will be freed when its memory owner"]
    #[doc = " is freed. If the given symbol table has an external owner which has been freed, the behavior of this function is"]
    #[doc = " undefined."]
    pub fn ion_catalog_close(hcatalog: hCATALOG) -> iERR;
}
extern "C" {
    pub static mut g_ion_debug_tracing: BOOL;
}
extern "C" {
    pub fn ion_debug_has_tracing() -> BOOL;
}
extern "C" {
    pub fn ion_debug_set_tracing(state: BOOL);
}
extern "C" {
    pub fn _ion_decimal_number_alloc(
        owner: *mut ::std::os::raw::c_void,
        decimal_digits: SIZE,
        p_number: *mut *mut decNumber,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_decimal_from_string_helper(
        str_: *const ::std::os::raw::c_char,
        context: *mut decContext,
        owner: hOWNER,
        p_quad: *mut decQuad,
        p_num: *mut *mut decNumber,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_decimal_to_string_quad_helper(
        value: *const decQuad,
        p_string: *mut ::std::os::raw::c_char,
    ) -> iERR;
}
extern "C" {
    pub fn _ion_decimal_to_string_number_helper(
        value: *const decNumber,
        p_string: *mut ::std::os::raw::c_char,
    ) -> iERR;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
